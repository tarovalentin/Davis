(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



If[MemberQ[$Packages,"HPL`"],Print["Package HPL already loaded..."];Abort[]]


BeginPackage["HPL`",{"Global`"}]


Print["*-*-*-*-*-* HPL 2.0 *-*-*-*-*-*\n\nAuthor: Daniel Maitre, University of Zurich"];


$HPLFunctions=Sort[{"HPL","HPLAnalyticContinuation","HPLAtoM","HPLConvertToKnownFunctions","HPLConvertToSimplerArgument","HPLLogExtract","HPLMtoA","HPLProductExpand","HPLReduceToMinimalSet","MZV","HPLpm21m1","HPL1m12pm","HPLInt","HPLArgTransform","HPLI"}]


$HPLOptions={"$HPLAnalyticContinuationSign"->$HPLAnalyticContinuationSign,"$HPLAutoConvertToKnownFunctions"->$HPLAutoConvertToKnownFunctions,"$HPLAutoConvertToSimplerArgument"->$HPLAutoConvertToSimplerArgument,"$HPLAutoLogExtract"->$HPLAutoLogExtract,"$HPLAutoProductExpand"->$HPLAutoProductExpand,"$HPLAutoReduceToMinimalSet"->$HPLAutoReduceToMinimalSet}


HPL::usage="HPL[{m1,...,mk},x] is the harmonic polylogarithm \!\(\*SubscriptBox[\(Li\), \(m1, m2,  ... , mk\)]\)(x)"


MZV::usage="MZV[{m1,...,mk}] is the multiple zeta value of {m1,...,mk}"


HPLMtoA::usage="HPLMtoA[m_List] converts the list m in the \"m\" notation into a list in the \"a\" notation"
HPLAtoM::usage="HPLAtoM[a_List] converts the list a in the \"a\" notation into a list in the \"m\" notation"

HPLLogExtract::usage="HPLLogExtract[x] Extracts the logarithmic divergencies of the HPL of the expression x."


HPLConvertToKnownFunctions::usage="HPLConvertToKnownFunctions[x] returns the expression x with all HPL's replaced by their representation in terms of more common function (when possible)."


HPLProductExpand::usage="HPLProductExpand[x] returns x with all products of HPL's replaced by their expansion as a sum of single HPL's. "


HPLConvertToSimplerArgument::usage="HPConvertToSimplerArgument[x] returns its argument with the HPL of argument -t, 1-t, t^2, t/(t-1),(1-t)/(1+t) should be converted into HPL's of argument t."


HPLReduceToMinimalSet::usage="HPLReduceToMinimalSet[x] returns its argument with the HPL's reduced to a minimal set."


HPLAnalyticContinuation::usage="HPLAnalyticContinuation[x,AnalyticContinuationRegion->r,AnalyticContinuationSign->s] gives the analytic continuation of the HPL's in the expression x. For symbolic arguments, the interval where the argument is defined can be given with r (more details with ?AnalyticContinuationRegion). The prescription for the values on the branch cuts is given by the value of s (more details with ?AnalyticContinuationSign)"

minftom1::usage="Value for the option AnalyticContinuationRegion representing the interval (-\[Infinity],-1)"
m1to0::usage="Value for the option AnalyticContinuationRegion representing the interval (-1,0)"
onetoinf::usage="Value for the option AnalyticContinuationRegion representing the interval (1,\[Infinity])"

AnalyticContinuationRegion::usage="AnalyticContinuationRegion is an option for the function HPLAnalyticContinuation which specifies the interval of  the real axis from where the arguments of the HPL's are to be brought to the interval (0,1). The possible values are \n minftom1 for (-\[Infinity],-1) \n m1to0 for (-1,0),\n onetoinf for (1,\[Infinity])."

AnalyticContinuationSign::usage="AnalyticContinuationSign is an option for the function HPLAnalyticContinuation which specifies from which side of the branch cut the argument has to be approched. For AnalyticContinuationSign=1, the argument of the HPL HPL[{...},x] is understood as x+\[ImaginaryI]\[Delta] with \[Delta] infinitesimal and positive. For AnalyticContinuationSign=-1 it is understood as x-\[ImaginaryI]\[Delta]. If the option is not sepecified, the default value is +1."



HPLInt::usage="HPLInt[x,t] returns a primitive of x with respect to t. It works for cases of the form:\n
t^j/(1-t^2)^k HPL[{...},t]\n
t^j/(1-t)^k HPL[{...},t]\n
t^j/(1+t)^k HPL[{...},t] "


HPLArgTransform::usage="HPLArgTransform[x,r,delta] transform the argument of the HPLs in x using the rule r. This rule has to be one of\n
x->-x\n
x->1-x\n
x->\!\(\*SqrtBox[\(x\)]\)\n
x->x/(x-1)\n
x->(1-x)/(1+x)\n
x->1/x\n
the rule may be expressed in terms of any symbol. The argument delta is optional. It fixes whether the argument is in the upper (delta=+1) or in the lower (delta=-1) half complex plane. It can also be left symbolic. The default value for delta if it is omitted is $HPLAnalyticContinuationSign."


HPLpm21m1::usage="HPLpm21m1[x] Converts HPLs of +- weights into HPLs of integer weights. \n
HPLpm21m1[{...},f] converts a vector in +- notation into the corresponding sum of vectors in integer notation with head f."


HPL1m12pm::usage="HPL1m12pm[x] Converts HPLs of integer weights into HPLs of +- weights. \n
HPL1m12pm[{...},f] converts a vector in integer notation into the corresponding sum of vectors in +- notation with head f."


plus::usage="plus is the + weight for the HPLs"
minus::usage="minus is the - weight for the HPLs"


HPLI::usage="HPLI[m] is the HPL[m,x] of weight m evaluated at x=\[ImaginaryI]" 


Unprotect[Integrate];


$HPLAutoLogExtract::usage="Sets whether the Logs of x and 1-x should be extracted automatically. Default is True"


$HPLAutoConvertToKnownFunctions::usage="Sets whether the Harmonic Polylogs should be replaced by their expressions in terms of known function, when possible. Default is True"


$HPLAutoProductExpand::usage="Sets whether products of HPL should be expanded or not. Default is True."


$HPLAutoReduceToMinimalSet::usage="Sets whether the HPL should be reduced to a minimal set. Default is True"


$HPLAutoConvertToSimplerArgument::usage="Sets whether the HPL of argument -t, 1-t, t^2, t/(t-1),(1-t)/(1+t) should be converted into HPL's of argument t. Default is False"


$HPLAnalyticContinuationSign::usage="$HPLAnalyticContinuationSign is either +1 or -1. It sets the sign of the infinitesimal imaginary part \[Delta] of the argument -x+\[Delta]\[ImaginaryI] for the analytic continuation in the interval (-1,0)."


HPLs6::usage="HPLs6 is the harmonic sum S(-5,-1;\[Infinity]). Its numerical value is 0.9874414264032997137..."
HPLs7a::usage="HPLs7a is the harmonic sum S(-5,-1,-1;\[Infinity]). Its numerical value is -0.9529600757562986034..."
HPLs7b::usage="HPLs7b is the harmonic sum S(5,-1,1;\[Infinity]). Its numerical value is 1.0291212629643245342..."
HPLs8a::usage="HPLs8a is the harmonic sum S(5,3;\[Infinity]). Its numerical value is 1.0417850291827918834..."
HPLs8b::usage="HPLs8b is the harmonic sum S(-7,-1;\[Infinity]). Its numerical value is 0.99644774839783766600..."
HPLs8c::usage="HPLs8c is the harmonic sum S(-5,-1,-1,-1;\[Infinity]). Its numerical value is 0.98396667382173367094..."
HPLs8d::usage="HPLs8d is the harmonic sum S(-5,-1,1,1;\[Infinity]). Its numerical value is 0.99996261346268344768..."
Sinf::usage="Sinf is the divergent harmonic sum \!\(\*UnderscriptBox[OverscriptBox[\(\[Sum]\), \(\[Infinity]\)], \(i = 1\)]\)\!\(\*FractionBox[\(1\), \(i\)]\) = H[{1},1]"


HPLAutoAnalyticContinuation::wrongoption="Not allowed option for AnalyticContinuationSign. The allowed values are  \n minftom1 for (-\[Infinity],-1) \n m1to0 for (-1,0),\n onetoinf for (1,\[Infinity])."


HPLLogExtract::AutoProductExpand="HPLLogExtract called with option $HPLAutoProductExpand switched on and $HPLAutoConvertToKnownFunctions switched off. HPLLogExtract will have no effects."


HPLArgTransform::BadRule="The rhs of the rule `1` in HPLArgTransform does not depend on the lhs."


HPLArgTransform::UnKnownRule="Rule `1` in HPLArgTransform could not be identified as an implemented transformation"


HPLArgTransform::WrongWeight="The argument transformation `1` attempted is not defined for the weight vector `2`"


Begin["`Private`"]


Weight[mm_List]:=Apply[Plus,Abs/@(mm/.{0->1,plus->1,minus->1})]
Weight[HPL[mm_List,x_]]:=Apply[Plus,Abs/@(mm/.{0->1,plus->1,minus->1})]


HPL/:HPL[mm_List,x_]:=HPL[HPLAtoM[mm],x]/;MatchQ[mm,{_Integer...,0,(_Integer?Positive | _Integer?Negative)..,_Integer...}]


HPL/:HPL[mm:{_Integer...,0,(_Integer?Positive | _Integer?Negative)..,_Integer...},x_]:=HPL[HPLAtoM[mm],x]


HPLAtoM[mm_List]:=Module[{ii,res},
res={};
For[ii=1,ii<=Length[mm],ii++,Switch[mm[[-ii]],
0,Switch[Length[res],
0,res=Prepend[res,0],
_,Switch[res[[1]],
0,res=Prepend[res,0],
_Integer?Positive,res=ReplacePart[res,res[[1]]+1,1],
_Integer?Negative,res=ReplacePart[res,res[[1]]-1,1],
_,res=Prepend[res,0]
]],
_,res=Prepend[res,mm[[-ii]]]
]
];
Return[res]
]



HPLMtoA[mm_List]:=Module[{res,ii},
res={};
For[ii=1,ii<=Length[mm],ii++,Switch[mm[[ii]],
0,res=Append[res,0],
_Integer?Positive,For[jj=1,jj<mm[[ii]],jj++,res=Append[res,0]];res=Append[res,1],
_Integer?Negative,For[jj=1,jj<-mm[[ii]],jj++,res=Append[res,0]];res=Append[res,-1],
_,res=Append[res,mm[[ii]]]
]
];res
];


plus[s_Plus]:=plus/@s
plus[c_ h_HPL]:=c plus[h]
plus[HPL[mm_List,x_]]:=HPL[Flatten[{1,mm}],x]+HPL[Flatten[{-1,mm}],x]
plus[x_]:=x
minus[s_Plus]:=minus/@s
minus[c_ h_HPL]:=c minus[h]
minus[HPL[mm_List,x_]]:=HPL[Flatten[{1,mm}],x]-HPL[Flatten[{-1,mm}],x]
minus[x_]:=x
zero[s_Plus]:=zero/@s
zero[c_ h_HPL]:=c zero[h]
zero[HPL[{mm___},x_]]:=HPL[{0,mm},x]
zero[x_]:=x


HPLpm21m1[ex_]:=ex//.{HPL[{mm1___,plus,mm2___},x_]->HPL[{mm1,1,mm2},x]+HPL[{mm1,-1,mm2},x],HPL[{mm1___,minus,mm2___},x_]->HPL[{mm1,1,mm2},x]-HPL[{mm1,-1,mm2},x]}


HPLpm21m1[ll:{(plus|0|minus)..},f_]:=H@@ll//.{H[mm1___,plus,mm2___]->H[mm1,1,mm2]+H[mm1,-1,mm2],H[mm1___,minus,mm2___]->H[mm1,1,mm2]-H[mm1,-1,mm2]}/.h_H:>(f)@@h


HPL1m12pm[ex_]:=ex//.{HPL[{mm1___,1,mm2___},x_]:>(HPL[{mm1,plus,mm2},x]+HPL[{mm1,minus,mm2},x])/2,HPL[{mm1___,-1,mm2___},x_]:>1/2 (HPL[{mm1,plus,mm2},x]-HPL[{mm1,minus,mm2},x]),HPL[{mm1___,n_Integer?Positive,mm2___},x_]:>1/2 (HPL[Flatten[{mm1,Table[0,{ii,1,n-1}],plus,mm2}],x]+HPL[Flatten[{mm1,Table[0,{ii,1,n-1}],minus,mm2}],x]),HPL[{mm1___,n_Integer?Negative,mm2___},x_]:>1/2 (HPL[Flatten[{mm1,Table[0,{ii,1,-n-1}],plus,mm2}],x]-HPL[Flatten[{mm1,Table[0,{ii,1,-n-1}],minus,mm2}],x])}//Expand


HPL1m12pm[ll_List,f_]:=H@@ll//.{H[mm1___,1,mm2___]:>(H[mm1,plus,mm2]+H[mm1,minus,mm2])/2,H[mm1___,-1,mm2___]:>1/2 (H[mm1,plus,mm2]-H[mm1,minus,mm2]),H[mm1___,n_Integer?Positive,mm2___]:>1/2 (H@@Flatten[{mm1,Table[0,{ii,1,n-1}],plus,mm2}]+H@@Flatten[{mm1,Table[0,{ii,1,n-1}],minus,mm2}]),H[mm1___,n_Integer?Negative,mm2___]:>1/2 (H@@Flatten[{mm1,Table[0,{ii,1,-n-1}],plus,mm2}]-H@@Flatten[{mm1,Table[0,{ii,1,-n-1}],minus,mm2}])}/.h_H:>f@@h//Expand



HPLMtoA[mm_List]:=Module[{res,ii},
res={};
For[ii=1,ii<=Length[mm],ii++,Switch[mm[[ii]],
0,res=Append[res,0],
_Integer?Positive,For[jj=1,jj<mm[[ii]],jj++,res=Append[res,0]];res=Append[res,1],
_Integer?Negative,For[jj=1,jj<-mm[[ii]],jj++,res=Append[res,0]];res=Append[res,-1],
Complex[0,_Integer?Positive],For[jj=1,jj<-I mm[[ii]],jj++,res=Append[res,0]];res=Append[res,I],
Complex[_Integer?Negative],For[jj=1,jj<I mm[[ii]],jj++,res=Append[res,0]];res=Append[res,-I]
]
];
Return[res]
]/;ArrayQ[mm,1,(IntegerQ[#]||MatchQ[#,Complex[0,_Integer]]&)]

HPLAtoM[mm_List]:=Module[{ii,res},
res={};
For[ii=1,ii<=Length[mm],ii++,Switch[mm[[-ii]],
0,Switch[Length[res],
0,res=Prepend[res,0],
_,Switch[res[[1]],
	0,res=Prepend[res,0],
	_Integer?Positive,res=ReplacePart[res,res[[1]]+1,1],
	_Integer?Negative,res=ReplacePart[res,res[[1]]-1,1],
	Complex[0,_Integer?Positive],res=ReplacePart[res,res[[1]]+I,1],
	Complex[0,_Integer?Negative],res=ReplacePart[res,res[[1]]-I,1]
]],
_,res=Prepend[res,mm[[-ii]]]
]
];
Return[res]
]/;ArrayQ[mm,1,(IntegerQ[#]||MatchQ[#,Complex[0,_Integer]]&)]




TrueLength[L_List]:=Length[HPLAtoM[L/.{plus->1,minus->1}]]


HPL/: Derivative[mm:{(0)..},1][HPL]:=If[MatchQ[#2,0],If[Not[MatchQ[#1[[-1]],0]],If[1>=TrueLength[#1],S[#1,1],0],HPL[{0},0]],DerofHPL[#1,#2]]&


HPL/: Derivative[0,1][HPL]:=If[MatchQ[#2,0],If[Not[MatchQ[#1[[-1]],0]],If[1>=TrueLength[#1],S[#1,1],0],HPL[{0},0]],DerofHPL[#1,#2]]&


HPL/: Derivative[mm:{(0)..},n_Integer?(#>1&)][HPL]:=If[MatchQ[#2,0],If[Not[MatchQ[#1[[-1]],0]],If[n>=TrueLength[#1],n! S[#1,n],0],HPL[{0},0]],Derivative[0,1][Derivative[mm,n-1][HPL]][#1,#2]]&
HPL/: Derivative[0,n_Integer?(#>1&)][HPL]:=If[#2==0,If[Not[MatchQ[#1[[-1]],0]],If[n>=TrueLength[#1],n! S[#1,n],0],HPL[{0},0]],Derivative[0,1][Derivative[0,n-1][HPL]][#1,#2]]&


plusorminus[j_]:=If[EvenQ[j],plus,minus]


plusminusHPLProductExpand[x_]:=x//pm21m1//Expand//HPLProductExpand//one2pm//Expand


DerofHPL:=Switch[
Length[#1],
	0,0,
	1,Switch[#1[[1]],
		0,1/#2,
		1,1/(1-#2),
		-1,1/(1+#2),
		plus,2/(1-#2^2),
		minus,2 #2/(1-#2^2),
		sq,1/Sqrt[1-#2^2],
		sq2,1/#2/Sqrt[1-#2^2],
		n_Integer?Positive,1/(#2) HPL[{#1[[1]]-1},#2],
		n_Integer?Negative,1/(#2) HPL[{#1[[1]]+1},#2],
		_,$HPLDerivativeFailed
	],
	_,Switch[#1[[1]],
		0,1/#2 HPL[Delete[#1,1],#2],
		1,1/(1-#2) HPL[Delete[#1,1],#2],
		-1,1/(1+#2) HPL[Delete[#1,1],#2],
		plus,2/(1-#2^2) HPL[Delete[#1,1],#2],
		minus,2 #2/(1-#2^2) HPL[Delete[#1,1],#2],
		sq,1/Sqrt[1-#2^2] HPL[Delete[#1,1],#2],
		sq2,1/#2/Sqrt[1-#2^2] HPL[Delete[#1,1],#2],
		n_Integer?Positive,1/#2 HPL[ReplacePart[#1,#1[[1]]-1,1],#2],
		n_Integer?Negative,1/#2 HPL[ReplacePart[#1,#1[[1]]+1,1],#2],
		_,$HPLDerivativeFailed
	]
]&


HPLConvertToKnownFunctions[HPL[{1},x_?(!SameQ[#,1]&),___DoConvert]]:=-Log[1-x]
HPLConvertToKnownFunctions[HPL[{0},x_?(!SameQ[#,0]&),___DoConvert]]:=Log[x]
HPLConvertToKnownFunctions[HPL[{-1},x_?(!SameQ[#,-1]&),___DoConvert]]:=Log[1+x]
HPLConvertToKnownFunctions[HPL[{-1},-1,___DoConvert]]:=-HPL[{1},1]


HPLConvertToKnownFunctions[HPL[{1,1},x_,___DoConvert]]:=1/2 Log[1-x]^2
HPLConvertToKnownFunctions[HPL[{1,-1},x_,___DoConvert]]:=PolyLog[2,(1-x)/2]-Log[2] Log[1-x]-PolyLog[2,1/2]
HPLConvertToKnownFunctions[HPL[{-1,1},x_,___DoConvert]]:=PolyLog[2,(1+x)/2]-Log[2] Log[1+x]-PolyLog[2,1/2]
HPLConvertToKnownFunctions[HPL[{-1,0},x_,___DoConvert]]:=Log[1+x] Log[x]+PolyLog[2,-x]
HPLConvertToKnownFunctions[HPL[{-2},x_,___DoConvert]]:=-PolyLog[2,-x]
HPLConvertToKnownFunctions[HPL[{1,0},x_,___DoConvert]]:=-Log[1-x] Log[x]-PolyLog[2,x]



HPLConvertToKnownFunctions[HPL[{1,2},x_,___DoConvert]]:=-2 PolyLog[1,2,x]-Log[1-x] PolyLog[2,x]
HPLConvertToKnownFunctions[HPL[{2,1},x_,___DoConvert]]:=PolyLog[1,2,x]
HPLConvertToKnownFunctions[HPL[{1,1,1},x_,___DoConvert]]:=-1/6 Log[1-x]^3
HPLConvertToKnownFunctions[HPL[{2,-1},x_,___DoConvert]]:=PolyLog[3,2 x/(1+x)]-PolyLog[3,x/(1+x)]-PolyLog[3,(1+x)/2]+PolyLog[3,1/2]-PolyLog[3,x]+Log[1+x] PolyLog[2,1/2]+Log[1+x] PolyLog[2,x]+1/2  Log[2] Log[1+x]^2
HPLConvertToKnownFunctions[HPL[{-2,1},x_,___DoConvert]]:=-PolyLog[1,2,x]+PolyLog[3,-2 x/(1-x)]-PolyLog[3,-x]-PolyLog[3,(1-x)/2]+PolyLog[3,1/2]+PolyLog[3,x]+Log[1-x] PolyLog[2,-x]+Log[1-x] PolyLog[2,1/2]-Log[1-x] PolyLog[2,x]+1/2 Log[2] Log[1-x]^2-1/6 Log[1-x]^3
HPLConvertToKnownFunctions[HPL[{-2,-1},x_,___DoConvert]]:=PolyLog[1,2,-x]
HPLConvertToKnownFunctions[HPL[{1,-1,-1},x_,___DoConvert]]:=-1/2 Log[(1-x)/2] Log[1+x]^2-Log[1+x] PolyLog[2,(1+x)/2]-PolyLog[3,1/2]+PolyLog[3,(1+x)/2]
HPLConvertToKnownFunctions[HPL[{-1,1,1},x_,___DoConvert]]:=1/2 Log[(1+x)/2] Log[1-x]^2+Log[1-x] PolyLog[2,(1-x)/2]+PolyLog[3,1/2]-PolyLog[3,(1-x)/2]
HPLConvertToKnownFunctions[HPL[{-1,-2},x_,___DoConvert]]:=(-(1/6))*Pi^2*Log[1+x]-Log[1+x]*PolyLog[2,1+x]+2*PolyLog[3,1+x]-2*Zeta[3]
HPLConvertToKnownFunctions[HPL[{-1,2},x_,___DoConvert]]:=(1/12)*(-4*Log[2]^3+Pi^2*Log[4]+(Pi^2+6*Log[2]^2)*Log[1-x]+2*Log[1-x]^2*(Log[(1-x)/8]-3*Log[x])-Log[1+x]*(Pi^2-6*Log[2]^2+Log[64]*Log[1+x])-12*Log[1-x]*PolyLog[2,-x]+12*PolyLog[3,(1-x)/2]-12*PolyLog[3,1-x]+12*PolyLog[3,-x]-12*PolyLog[3,(2*x)/(-1+x)]+12*PolyLog[3,x/(1+x)]-12*PolyLog[3,(2*x)/(1+x)]+12*PolyLog[3,(1+x)/2]-9*Zeta[3]);
HPLConvertToKnownFunctions[HPL[{-1,1,-1},x_,___DoConvert]]:=(-(1/6))*Pi^2*Log[2]+Log[2]^3/3+Log[(1-x)/2]*Log[1+x]^2+Log[1+x]*(-(Pi^2/12)+Log[2]^2/2-Log[2]*Log[1-x]+PolyLog[2,(1-x)/2])+2*Log[1+x]*PolyLog[2,(1+x)/2]-2*PolyLog[3,(1+x)/2]+(7*Zeta[3])/4
HPLConvertToKnownFunctions[HPL[{-1,-1,1},x_,___DoConvert]]:=(-4 Log[2]^3 + Pi^2 Log[4] - 2 Log[1 + x] (Pi^2 - 6 Log[2]^2 + Log[64] Log[1 + x])+24 PolyLog[3, (1 + x)/2] - 21 Zeta[3])/24
HPLConvertToKnownFunctions[HPL[{1,-1,1},x_,___DoConvert]]:=(1/12)*(-4*Log[2]^3+Pi^2*Log[4]+Log[1-x]*(Pi^2-6*Log[2]^2-12*Log[1-x]*Log[(1+x)/2]+12*Log[2]*Log[1+x])-12*Log[1-x]*(2*PolyLog[2,(1-x)/2]+PolyLog[2,(1+x)/2])+24*PolyLog[3,(1-x)/2]-21*Zeta[3])
HPLConvertToKnownFunctions[HPL[{1,1,-1},x_,___DoConvert]]:=Log[1-x]*(PolyLog[2,(1-x)/2]+PolyLog[2,(1+x)/2])+(1/24)*(4*Log[2]^3-Pi^2*Log[4]-2*Log[1-x]*(Pi^2-6*Log[2]^2+Log[64]*Log[1-x]-12*Log[(1-x)/2]*Log[1+x])-24*PolyLog[3,(1-x)/2]+21*Zeta[3])
HPLConvertToKnownFunctions[HPL[{1,-2},x_,___DoConvert]]:=(1/12)*(-4*Log[2]^3+Pi^2*Log[4]+(Pi^2+6*Log[2]^2)*Log[1-x]+2*Log[1-x]^2*(Log[(1-x)/8]-3*Log[x])-Log[1+x]*(Pi^2-6*Log[2]^2+Log[64]*Log[1+x])-12*Log[1+x]*PolyLog[2,x]+12*PolyLog[3,(1-x)/2]-12*PolyLog[3,1-x]+12*PolyLog[3,-x]-12*PolyLog[3,(2*x)/(-1+x)]+12*PolyLog[3,x/(1+x)]-12*PolyLog[3,(2*x)/(1+x)]+12*PolyLog[3,(1+x)/2]-9*Zeta[3])
HPLConvertToKnownFunctions[HPL[{-1,0,0},x_,___DoConvert]]:=(1/2)*Log[x]^2*Log[1+x]+Log[x]*PolyLog[2,-x]-PolyLog[3,-x]
HPLConvertToKnownFunctions[HPL[{-2,0},x_,___DoConvert]]:=-Log[x] PolyLog[2,-x]+2 PolyLog[3,-x]

HPLConvertToKnownFunctions[HPL[{1,-1,0},x_,___DoConvert]]:=1/24 (4 Log[2]^3-\[Pi]^2 Log[4]-4 Log[1-x]^3+12 Log[1-x]^2 Log[2 x]+2 Log[x] (\[Pi]^2-6 Log[2]^2+12 Log[2] Log[1+x])-2 Log[1-x] (\[Pi]^2+6 Log[2]^2+12 Log[x] Log[1+x])-24 Log[x] PolyLog[2,(1+x)/2]-24 PolyLog[3,(1-x)/2]+24 PolyLog[3,1-x]+48 PolyLog[3,x]+24 PolyLog[3,(2 x)/(-1+x)]-6 PolyLog[3,x^2]-3 Zeta[3])
HPLConvertToKnownFunctions[HPL[{1,0,0},x_,___DoConvert]]:=(-(1/2))*Log[1-x]*Log[x]^2-Log[x]*PolyLog[2,x]+PolyLog[3,x]
HPLConvertToKnownFunctions[HPL[{2,0},x_,___DoConvert]]:=Log[x] PolyLog[2,x]-2 PolyLog[3,x]
HPLConvertToKnownFunctions[HPL[{1,1,0},x_,___DoConvert]]:=Log[1-x]^2*Log[x]+Log[1-x]*PolyLog[2,1-x]+Log[1-x]*PolyLog[2,x]-PolyLog[3,1-x]+Zeta[3]
HPLConvertToKnownFunctions[HPL[{-1,-1,0},x_,___DoConvert]]:=(1/6)*(Log[1+x]*(Pi^2+3*(-Log[-x]+Log[x])*Log[1+x])-6*PolyLog[3,1+x]+6*Zeta[3])
HPLConvertToKnownFunctions[HPL[{-1,1,0},x_,___DoConvert]]:=(1/24)*(4*Log[2]^3-Pi^2*Log[4]-2*Log[x]*(Pi^2-6*Log[2]^2+12*Log[2]*Log[1+x])+2*Log[1+x]*(Pi^2-6*Log[2]^2+Log[64]*Log[1+x])+24*Log[x]*PolyLog[2,(1+x)/2]-24*PolyLog[3,x]-24*PolyLog[3,x/(1+x)]+24*PolyLog[3,(2*x)/(1+x)]-24*PolyLog[3,(1+x)/2]+21*Zeta[3])


HPLConvertToKnownFunctions[HPL[{1,3},x_,___DoConvert]]:=-1/2  PolyLog[2,x]^2-Log[1-x] PolyLog[3,x]
HPLConvertToKnownFunctions[HPL[{1,1,2},x_,___DoConvert]]:=1/2 Log[1-x]^2 PolyLog[2,x]+2 Log[1-x] PolyLog[1,2,x]+3 PolyLog[1,3,x]
HPLConvertToKnownFunctions[HPL[{1,2,1},x_,___DoConvert]]:=-Log[1-x] PolyLog[1,2,x]-3 PolyLog[1,3,x]
HPLConvertToKnownFunctions[HPL[{2,2},x_,___DoConvert]]:=-2 PolyLog[2,2,x]+1/2 PolyLog[2,x]^2
HPLConvertToKnownFunctions[HPL[{3,1},x,___DoConvert]]:=PolyLog[2,2,x]
HPLConvertToKnownFunctions[HPL[{2,1,1},x_,___DoConvert]]:=PolyLog[1,3,x]
HPLConvertToKnownFunctions[HPL[{1,1,1,1},x_,___DoConvert]]:=1/24 Log[1-x]^4
HPLConvertToKnownFunctions[HPL[{-1,1,1,1},x_,___DoConvert]]:=(-(1/6))*Log[1-x]^3*Log[(1+x)/2]-(1/2)*Log[1-x]^2*PolyLog[2,(1-x)/2]+Log[1-x]*PolyLog[3,(1-x)/2]+PolyLog[4,1/2]-PolyLog[4,(1-x)/2]
HPLConvertToKnownFunctions[HPL[{-1,1,-1,-1},x_,___DoConvert]]:=(1/24)*((-4*Log[2]^3 + Pi^2*Log[4])*Log[1 + x] - 
   72*PolyLog[4, 1/2] + 72*PolyLog[4, (1 + x)/2] +3*Log[1 + x]*(4*Log[1 + x]*PolyLog[2, (1 + x)/2] - 16*PolyLog[3, (1 + x)/2] - 7*Zeta[3]))
HPLConvertToKnownFunctions[HPL[{-3,-1},x_,___DoConvert]]:=PolyLog[2,2,-x]
HPLConvertToKnownFunctions[HPL[{-2,-1,-1},x_,___DoConvert]]:=-(Pi^4/90) + (1/6)*Log[-x]*Log[1 + x]^3 + 
  (1/2)*Log[1 + x]^2*PolyLog[2, 1 + x] - 
  Log[1 + x]*PolyLog[3, 1 + x] + PolyLog[4, 1 + x]


HPLConvertToKnownFunctions[HPL[{4,1},x_,___DoConvert]]:=PolyLog[3,2,x]
HPLConvertToKnownFunctions[HPL[{3,1,1},x_,___DoConvert]]:=PolyLog[2,3,x]


HPLConvertToKnownFunctions[HPL[mm:{(1)..},x_?(!SameQ[#,1]&),___DoConvert]]:=1/(Length[mm]!) (-Log[1-x])^Length[mm]
HPLConvertToKnownFunctions[HPL[mm:{(-1)..},x_,___DoConvert]]:=1/(Length[mm]!) (Log[1+x])^Length[mm]



HPLConvertToKnownFunctions[HPL[{n_Integer?(#>1&)},x_,___DoConvert]]:=PolyLog[n,x]
HPLConvertToKnownFunctions[HPL[{n_Integer?(#<-1&)},x_?(!MatchQ[#,-1]&),___DoConvert]]:=-PolyLog[-n,-x]
HPLConvertToKnownFunctions[HPL[mm:{1,(1)..},x_,___DoConvert]]:=(-1)^Length[mm] Log[1-x]^Length[mm]/Length[mm]!
HPLConvertToKnownFunctions[HPL[mm:{-1,((-1)..)},x_,___DoConvert]]:=Log[1+x]^Length[mm]/Length[mm]!
HPLConvertToKnownFunctions[HPL[mm:{0,((0)..)},x_,___DoConvert]]:=Log[x]^Length[mm]/Length[mm]!
HPLConvertToKnownFunctions[HPL[{m_Integer?(#>1&),o:((1)..)},x_,___DoConvert]]:=PolyLog[m-1,Length[{o}]+1,x]


knowns={__Integer}?(Weight[#]<4&)|{n_Integer}|{1,3}|{1,1,2}|{1,2,1}|{2,2}|{3,1}|{2,1,1}|{1,1,1,1}|{-1,1,1,1}|{-1,1,-1,-1}|{-3,-1}|{-2,-1,-1}|{4,1}|{3,1,1}|{(1)..}|{(-1)..}|x_?(MatchQ[#,Prepend[Table[1,{j,1,Length[#]-1}],n_Integer?Positive]]&)|{plus}|{minus}


HPLConvertToKnownFunctions[x_]:=(
Module[{res},
res=x/.HPL[mm_List?(MatchQ[#,knowns]&),xx_]:>HPLConvertToKnownFunctions[HPL[mm,xx,DoConvert[]]];
Return[res];
]
)


HPLConvertToKnownFunctions[HPL[{plus},x_?(!MatchQ[#,1]&),___DoConvert]]:=Log[(1+x)/(1-x)]
HPLConvertToKnownFunctions[HPL[{minus},x_?(!MatchQ[#,1]&),___DoConvert]]:=-Log[1-x^2]


HPL[mm_?(MatchQ[#,knowns]&),x_?(!MatchQ[#,1|1.]&)]:=HPLConvertToKnownFunctions[HPL[mm,x,DoConvert[]]]/;$HPLAutoConvertToKnownFunctions


newprod[a1_List,a2_List]:=Normal[SparseArray[Flatten[{Position[#,1],Position[#,2]}]->Join[a1,a2]]]&/@Permutations[PadLeft[PadLeft[{},Length[a2],2],Length[a1]+Length[a2],1]]


HPE = {HH[m1__]*HH[m2__] :> 
    Tr[Apply[HH, newprod[{m1}, {m2}], {1}]], 
   HH[m__]^(ex_) :> HH[m]^(ex - 2)*
     Tr[Apply[HH, newprod[{m}, {m}], {1}]]};


HProductExpand[x_] := (Module[{res},res = Expand[x] //. HPE; 
     Return[If[MatchQ[x, res], res, HProductExpand[
        res]]]])


HProductExpand3[x_]:=FixedPoint[Expand[#//.HPE]&,x]


newprod2[L_List]:=(p=Permutations[Flatten[Table[Table[j,{ii,1,Length[L[[j]]]}],{j,1,Length[L]}]]];Normal[SparseArray[Flatten[Table[Position[#,ii],{ii,1,Length[L]}]]->Join@@L]]&/@p)


HPLProductExpand[x_]:=(
Module[{res},
res=Expand[x]/.{HPL[m1:{_Integer...},xx_] HPL[m2:{_Integer..},xx_]:>((HProductExpand[(HH@@(HPLMtoA[m1])) (HH@@(HPLMtoA[m2]))])/.HH[mmm__]:>HPL[{mmm},xx]),HPL[m1_List,xx_]^ex_:>(HProductExpand[(HH@@(HPLMtoA[m1]))^ex]/.HH[mmm__]:>HPL[{mmm},xx])};
Return[If[MatchQ[x,res],res,HPLProductExpand[res]]]
]
)


HPLProductExpand[x_]:=(
Module[{res},
res=Expand[x]/.{HPL[m1_List,xx_] HPL[m2_List,xx_]:>((HProductExpand[(HH@@(HPLMtoA[m1])) (HH@@(HPLMtoA[m2]))])/.HH[mmm__]:>HPL[{mmm},xx]),HPL[m1_List,xx_]^ex_:>(HProductExpand[(HH@@(HPLMtoA[m1]))^ex]/.HH[mmm__]:>HPL[{mmm},xx])};
Return[If[MatchQ[x,res],res,HPLProductExpand[res]]]
]
)


Build[mm_List,a_List,b_List]:=(Module[{i},
res={};
i1=0;
i2=0;
For[i=1,i<=Length[mm],i++,res=Append[res,If[mm[[i]]==1,i1+=1;a[[i1]],i2+=1;b[[i2]]]]];
Return[res]]
)
OrderedMerge[l1_List,l2_List]:=(
Build[#,l1,l2]&/@Permutations[Join[Table[1,{ii,1,Length[l1]}],Table[2,{jj,1,Length[l2]}]]]
)


HPL/:HPL[m1_List,x_] HPL[m2_List,x_]:=Tr[HPL[#,x]&/@HPLAtoM/@OrderedMerge[HPLMtoA[m1],HPLMtoA[m2]]]/;$HPLAutoProductExpand
HPL/:HPL[m1_List,x_]^ex_:=Switch[ex,
0,1,
1,HPL[m1,x],
_Integer?Positive,HPL[m1,x]^(ex-2) Tr[HPL[#,x]&/@HPLAtoM/@OrderedMerge[HPLMtoA[m1],HPLMtoA[m1]]]
]/;IntegerQ[ex]&&Positive[ex]&&$HPLAutoProductExpand


HPLzwischen/:HPLzwischen[m1_List,x_] HPLzwischen[m2_List,x_]:=Tr[HPLzwischen[#,x]&/@HPLAtoM/@OrderedMerge[HPLMtoA[m1],HPLMtoA[m2]]]/;$HPLAutoProductExpand
HPLzwischen/:HPLzwischen[m1_List,x_]^ex_:=Switch[ex,
0,1,
1,HPLzwischen[m1,x],
_Integer?Positive,HPLzwischen[m1,x]^(ex-2) Tr[HPLzwischen[#,x]&/@HPLAtoM/@OrderedMerge[HPLMtoA[m1],HPLMtoA[m1]]]
]/;IntegerQ[ex]&&Positive[ex]&&$HPLAutoProductExpand


ProductExpansion={HPL[m1_List,x_] HPL[m2_List,x_]:>Tr[HPL[#,x]&/@HPLAtoM/@OrderedMerge[HPLMtoA[m1],HPLMtoA[m2]]],HPL[m1_List,x_]^ex_:>Switch[ex,
0,1,
1,HPL[m1,x],
_Integer?Positive,HPL[m1,x]^(ex-2) Tr[HPL[#,x]&/@HPLAtoM/@OrderedMerge[HPLMtoA[m1],HPLMtoA[m1]]]
]/;IntegerQ[ex]&&Positive[ex],HPL[m1_List,x_] HPL[m2_List,one]:>HPL[m1,x] HPLatOne[m2]}


ProductExpansionzwischen={HPLzwischen[m1_List,x_] HPLzwischen[m2_List,x_]:>Tr[HPLzwischen[#,x]&/@HPLAtoM/@OrderedMerge[HPLMtoA[m1],HPLMtoA[m2]]],HPLzwischen[m1_List,x_]^ex_:>Switch[ex,
0,1,
1,HPLzwischen[m1,x],
_Integer?Positive,HPLzwischen[m1,x]^(ex-2) Tr[HPLzwischen[#,x]&/@HPLAtoM/@OrderedMerge[HPLMtoA[m1],HPLMtoA[m1]]]
]/;IntegerQ[ex]&&Positive[ex],HPLzwischen[m1_List,x_] HPLzwischen[m2_List,one]:>HPLzwischen[m1,x] HPLatOne[m2]}


ProductExpand[x_]:=Expand[x]//.ProductExpansion
ProductExpandzwischen[x_]:=(Module[{remember=$HPLAutoProductExpand,res},
$HPLAutoProductExpand=True;
res=Expand[x]//.ProductExpansionzwischen;
$HPLAutoProductExpand=remember;
Return[If[MatchQ[x,res],res,HPLProductExpand[res]]];
])


NumberOfZerosfromRight[mm_List]:=Module[{i},For[i=1,i<=Length[mm],i++,If[Not[MatchQ[mm[[-i]],0]],Return[i-1]]];
Return[Length[mm]]]


NumberOfOnesfromLeft[mm_List]:=Module[{i},For[i=1,i<=Length[mm],i++,If[Not[MatchQ[mm[[i]],1]],Return[i-1]]];
Return[Length[mm]]]


NumberOfMinusOnesfromLeft[mm_List]:=Module[{i},For[i=1,i<=Length[mm],i++,If[Not[MatchQ[mm[[i]],-1]],Return[i-1]]];
Return[Length[mm]]]


HPLLogExtract[h:HPL[{_},_,___DoLogExtract]]:=h
HPLLogExtract[h:HPL[{_},_,DoLogExtract[]]]:=Delete[h,-1]


HPLLogExtract[HPL[mm:{1,(1)..},x_,___DoLogExtract]]:=1/Length[mm]! HPL[{1},x]^Length[mm] 
HPLLogExtract[HPL[mm:{0,(0)..},x_,___DoLogExtract]]:=1/Length[mm]! HPL[{0},x]^Length[mm] 


HPL[mm:({1,__Integer}|{__,0}),x_]:=HPLLogExtract[HPL[mm,x,DoLogExtract[]]]/;(($HPLAutoLogExtract&&Not[$HPLAutoProductExpand])||$HPLAutoConvertToKnownFunctions)


HPLLogExtract[HPL[mm:{__,0},x_,___DoLogExtract]]:=
	Module[{res},If[$HPLAutoProductExpand&&Not[$HPLAutoConvertToKnownFunctions],Message[HPLLogExtract::AutoProductExpand];Return[HPL[mm,x]]];res=LE2[H@@HPLMtoA[mm]];res/.H[mmm__]:>HPLLogExtract[HPL[{mmm},x]]//Expand]


HPLLogExtract[HPL[mm:{_?(!SameQ[#,1]&),___,_?(!SameQ[#,0]&)},x_,___DoLogExtract]]:=HPL[mm,x]


HPLLogExtract[HPL[mm:{___,(plus|minus),___,_?(!SameQ[#,0]&)},x_,___DoLogExtract]]:=HPL[mm,x]


HPLLogExtract[HPL[mm:{___,(plus|minus)},x_,___DoLogExtract]]:=HPL[mm,x]


HPL[mm:{_?(!SameQ[#,1]&),___,_?(!SameQ[#,0]&)},x_,DoLogExtract[]]:=HPL[mm,x]


HPL[mm:{_},x_,DoLogExtract[]]:=HPL[mm,x]


HPL[mm:{___,(plus|minus),___,_?(!SameQ[#,0]&)},x_,DoLogExtract[]]:=HPL[mm,x]


HPL[mm:{___,(plus|minus)},x_,DoLogExtract[]]:=HPL[mm,x]


HPLLogExtractMinus1[x_]:=(
Module[{remember1,remember2},
remember1=$HPLAutoLogExtract;
remember2=$HPLAutoProductExpand;
$HPLAutoLogExtract=False;
$HPLAutoProductExpand=False;
res=x//.LogExtractionMinus1;
$HPLAutoLogExtract=remember1;
$HPLAutoProductExpand=remember2;
Return[res];
]
)


HPLLogExtract[HPL[mm:{__Integer,0},x_,___DoLogExtract]]:=	1/(NumberOfZerosfromRight[mm]) (HPL[{0},x] HPLLogExtract[HPL[Delete[mm,-1],x]]-HPLLogExtract[Sum[Abs[mm[[j]]] HPL[Delete[ReplacePart[mm,Switch[mm[[j]],_Integer?Positive,mm[[j]]+1,_Integer?Negative,mm[[j]]-1],j],-1],x],{j,1,Length[mm]-NumberOfZerosfromRight[mm]}]])//Expand


HPLLogExtract[HPL[mm:{1,__Integer},x_,___DoLogExtract]]:=
	1/(NumberOfOnesfromLeft[mm]) (HPL[{1},x] HPLLogExtract[HPL[Delete[mm,1],x,DoLogExtract[]]]-HPLLogExtract[Sum[Switch[mm[[j]],
0,HPL[Join[Table[mm[[i]],{i,2,Length[mm]-NumberOfZerosfromRight[mm]}],
{NumberOfZerosfromRight[mm]-Length[mm]+j+1},
Table[0,{i,j+1,Length[mm]}]
],x],
_Integer?Positive,Sum[HPL[Delete[Insert[ReplacePart[mm,mm[[j]]-i+1,j],i,j],1],x],{i,2,mm[[j]]}]+HPL[Delete[Insert[mm,1,j+1],1],x],
_Integer?Negative,Sum[HPL[Delete[Insert[ReplacePart[mm,mm[[j]]+i-1,j],i,j],1],x],{i,2,-mm[[j]]}]+HPL[Delete[Insert[mm,1,j+1],1],x]
],{j,NumberOfOnesfromLeft[mm]+1,Length[mm]}]])//Expand


LogExtract[x_]:=x//.LogExtraction
LogExtractMinus1[x_]:=x//.LogExtractionMinus
LogExtractzwischen[x_]:=x//.LogExtractionzwischen


HPLLogExtract[x_]:=x/.h_HPL:>HPLLogExtract[h]


LogExtraction={HPL[mm:{__Integer,0},x_]:>
	1/(NumberOfZerosfromRight[mm]) (HPL[{0},x] HPL[Delete[mm,-1],x]-Sum[Abs[mm[[j]]] HPL[Delete[ReplacePart[mm,Switch[mm[[j]],_Integer?Positive,mm[[j]]+1,_Integer?Negative,mm[[j]]-1],j],-1],x],{j,1,Length[mm]-NumberOfZerosfromRight[mm]}]),
HPL[mm:{1,__Integer},x_]:>
	1/(NumberOfOnesfromLeft[mm]) (HPL[{1},x] HPL[Delete[mm,1],x]-Sum[Switch[mm[[j]],
0,HPL[Join[Table[mm[[i]],{i,2,Length[mm]-NumberOfZerosfromRight[mm]}],
{NumberOfZerosfromRight[mm]-Length[mm]+j+1},
Table[0,{i,j+1,Length[mm]}]
],x],
_Integer?Positive,Sum[HPL[Delete[Insert[ReplacePart[mm,mm[[j]]-i+1,j],i,j],1],x],{i,2,mm[[j]]}]+HPL[Delete[Insert[mm,1,j+1],1],x],
_Integer?Negative,Sum[HPL[Delete[Insert[ReplacePart[mm,mm[[j]]+i-1,j],i,j],1],x],{i,2,-mm[[j]]}]+HPL[Delete[Insert[mm,1,j+1],1],x]
],{j,NumberOfOnesfromLeft[mm]+1,Length[mm]}])};

LogExtractionMinus1={HPL[mm:{__Integer,0},x_]:>
	1/(NumberOfZerosfromRight[mm]) (HPL[{0},x] HPL[Delete[mm,-1],x]-Sum[Abs[mm[[j]]] HPL[Delete[ReplacePart[mm,Switch[mm[[j]],_Integer?Positive,mm[[j]]+1,_Integer?Negative,mm[[j]]-1],j],-1],x],{j,1,Length[mm]-NumberOfZerosfromRight[mm]}]),
HPL[mm:{-1,__Integer},x_]:>
	1/(NumberOfMinusOnesfromLeft[mm]) (HPL[{-1},x] HPL[Delete[mm,1],x]-Sum[Switch[mm[[j]],
0,HPL[Join[Table[mm[[i]],{i,2,Length[mm]-NumberOfZerosfromRight[mm]}],
{NumberOfZerosfromRight[mm]-Length[mm]+j+1},
Table[0,{i,j+1,Length[mm]}]
],x],
_Integer?Positive,Sum[HPL[Delete[Insert[ReplacePart[mm,mm[[j]]-i+1,j],-i,j],1],x],{i,2,mm[[j]]}]+HPL[Delete[Insert[mm,-1,j+1],1],x],
_Integer?Negative,Sum[HPL[Delete[Insert[ReplacePart[mm,mm[[j]]+i-1,j],-i,j],1],x],{i,2,-mm[[j]]}]+HPL[Delete[Insert[mm,-1,j+1],1],x]
],{j,NumberOfMinusOnesfromLeft[mm]+1,Length[mm]}])};

LogExtractionzwischen={HPLzwischen[mm:{__Integer,0},x_]:>
	1/(NumberOfZerosfromRight[mm]) (HPLzwischen[{0},x] HPLzwischen[Delete[mm,-1],x]-Sum[Abs[mm[[j]]] HPLzwischen[Delete[ReplacePart[mm,Switch[mm[[j]],_Integer?Positive,mm[[j]]+1,_Integer?Negative,mm[[j]]-1],j],-1],x],{j,1,Length[mm]-NumberOfZerosfromRight[mm]}]),
HPLzwischen[mm:{1,__Integer},x_]:>
	1/(NumberOfOnesfromLeft[mm]) (HPLzwischen[{1},x] HPLzwischen[Delete[mm,1],x]-Sum[Switch[mm[[j]],
0,HPLzwischen[Join[Table[mm[[i]],{i,2,Length[mm]-NumberOfZerosfromRight[mm]}],
{NumberOfZerosfromRight[mm]-Length[mm]+j+1},
Table[0,{i,j+1,Length[mm]}]
],x],
_Integer?Positive,Sum[HPLzwischen[Delete[Insert[ReplacePart[mm,mm[[j]]-i+1,j],i,j],1],x],{i,2,mm[[j]]}]+HPLzwischen[Delete[Insert[mm,1,j+1],1],x],
_Integer?Negative,Sum[HPLzwischen[Delete[Insert[ReplacePart[mm,mm[[j]]+i-1,j],i,j],1],x],{i,2,-mm[[j]]}]+HPLzwischen[Delete[Insert[mm,1,j+1],1],x]
],{j,NumberOfOnesfromLeft[mm]+1,Length[mm]}])};


IntofHPLm1[HPL[mm1_List,one] HPL[mm2_List,x_],x_]:=HPLatOne[mm1] IntofHPLm1[ HPL[mm2,x],x]
IntofHPLm1[HPL[mm_List,one],x_]:=HPLatOne[mm] HPL[{1},x]
IntofHPLm1[HPL[mm_List,x_],x_]:=Switch[mm[[1]],
		n_Integer,HPL[Prepend[mm,1],x],
		_,$HPLIntegrateFailed
	]

IntofHPLm1[HPLzwischen[mm1_List,one] HPLzwischen[mm2_List,x_],x_]:=HPLatOne[mm1] IntofHPLm1[ HPLzwischen[mm2,x],x]
IntofHPLm1[HPLzwischen[mm_List,one],x_]:=HPLatOne[mm] HPLzwischen[{1},x]
IntofHPLm1[HPLzwischen[mm_List,x_],x_]:=Switch[mm[[1]],
		n_Integer,HPLzwischen[Prepend[mm,1],x],
		_,$HPLIntegrateFailed
	]

IntofHPLm1[y_,x_]:=y



IntofHPLp1[HPL[mm1_List,one] HPL[mm2_List,x_],x_]:=HPLatOne[mm1] IntofHPLp1[ HPL[mm2,x],x]
IntofHPLp1[HPL[mm_List,one],x_]:=HPLatOne[mm] HPL[{-1},x]

IntofHPLp1[HPL[mm1_List,minusone] HPL[mm2_List,x_],x_]:=HPL[mm1,-1] IntofHPLp1[ HPL[mm2,x],x]
IntofHPLp1[HPL[mm_List,minusone],x_]:=HPL[mm,-1] HPLzwischen[{-1},x]

IntofHPLp1[HPL[mm_List,x_],x_]:=Switch[mm[[1]],
		n_Integer,HPL[Prepend[mm,-1],x],
		_,$HPLIntegrateFailed
	]

IntofHPLp1[HPLzwischen[mm1_List,one] HPLzwischen[mm2_List,x_],x_]:=HPLatOne[mm1] IntofHPLp1[ HPLzwischen[mm2,x],x]

IntofHPLp1[HPLzwischen[mm_List,one],x_]:=HPLatOne[mm] HPLzwischen[{-1},x]

IntofHPLp1[HPLzwischen[mm1_List,minusone] HPLzwischen[mm2_List,x_],x_]:=HPL[mm1,-1] IntofHPLp1[HPLzwischen[mm2,x],x]
IntofHPLp1[HPLzwischen[mm_List,minusone],x_]:=HPL[mm,-1] HPLzwischen[{-1},x]

IntofHPLp1[HPLzwischen[mm_List,x_],x_]:=Switch[mm[[1]],
		n_Integer,HPLzwischen[Prepend[mm,-1],x],
		_,$HPLIntegrateFailed
	]
IntofHPLp1[y_,x_]:=y


IntofHPL0[HPL[mm_List,x_],x_]:=Switch[mm[[1]],
		0,HPL[Prepend[mm,0],x],
		n_Integer?Positive,HPL[ReplacePart[mm,mm[[1]]+1,1],x],
		n_Integer?Negative,HPL[ReplacePart[mm,mm[[1]]-1,1],x],
		_,$HPLIntegrateFailed
	]

IntofHPL0[HPLzwischen[mm1_List,one] HPLzwischen[mm2_List,x_],x_]:=HPLatOne[mm1] IntofHPL0[ HPLzwischen[mm2,x],x]
IntofHPL0[HPLzwischen[mm_List,one],x_]:=HPLatOne[mm] HPLzwischen[{0},x]

IntofHPL0[HPLzwischen[mm1_List,minusone] HPLzwischen[mm2_List,x_],x_]:=HPL[mm1,-1] IntofHPL0[ HPLzwischen[mm2,x],x]
IntofHPL0[HPLzwischen[mm_List,minusone],x_]:=HPL[mm,-1] HPLzwischen[{0},x]

IntofHPL0[HPL[mm_List,minusone],x_]:=HPL[mm,-1] HPLzwischen[{0},x]

IntofHPL0[HPLzwischen[mm_List,x_],x_]:=Switch[mm[[1]],
		0,HPLzwischen[Prepend[mm,0],x],
		n_Integer?Positive,HPLzwischen[ReplacePart[mm,mm[[1]]+1,1],x],
		n_Integer?Negative,HPLzwischen[ReplacePart[mm,mm[[1]]-1,1],x],
		_,$HPLIntegrateFailed
	]

IntofHPL0[y_,x_]:=y


Unprotect[Integrate];
Integrate/: Integrate[HPL[mm_List,t_]/(1-t_),{t_,0,x_}]:=IntofHPLm1[HPL[mm,x],x];
Integrate/: Integrate[HPL[mm_List,t_]/(1+t_),{t_,0,x_}]:=IntofHPLp1[HPL[mm,x],x];
Integrate/: Integrate[HPL[mm_List,t_]/(t_),{t_,0,x_}]:=IntofHPL0[HPL[mm,x],x];
Integrate/: Integrate[2 t_ HPL[mm_List,t_]/(1-Power[t_,2]),{t_,0,x_}]:=HPL[Prepend[mm,minus],x];
Integrate/: Integrate[2 HPL[mm_List,t_]/(1-(t_)^2),{t_,0,x_}]:=HPL[Prepend[mm,plus],x];
Protect[Integrate];



MinimalSetLoaded={};


Module[{ii},For[ii=2,ii<=10,ii++,If[FileType[ToFileName[{$HPLPath},"MinimalSet"<>ToString[ii]<>".m"]]==File,Get[ToFileName[{$HPLPath},"MinimalSet"<>ToString[ii]<>".m"]];MinimalSetLoaded=Append[MinimalSetLoaded,ii]]]]


Print["Rules for minimal set loaded for weights: "<>StringTake[StringJoin[ToString[#]<>", "&/@MinimalSetLoaded],{1,-3}]<>"."];


MinimalSetpmLoaded={};


Module[{ii},For[ii=2,ii<=10,ii++,If[FileType[ToFileName[{$HPLPath},"MinimalSetpm"<>ToString[ii]<>".m"]]==File,Get[ToFileName[{$HPLPath},"MinimalSetpm"<>ToString[ii]<>".m"]];MinimalSetpmLoaded=Append[MinimalSetpmLoaded,ii]]]]


Print["Rules for minimal set for + - weights loaded for weights: "<>StringTake[StringJoin[ToString[#]<>", "&/@MinimalSetpmLoaded],{1,-3}]<>"."];


HPLReduceToMinimalSet[x_]:=(Module[{remember1,remember2,res},
remember1=$HPLAutoProductExpand;
remember2=$HPLAutoReduceToMinimalSet;
$HPLAutoProductExpand=False;
$HPLAutoReduceToMinimalSet=True;
res=x/.HPL[mm_List,y_]->HPL[mm,y];
$HPLAutoProductExpand=remember1;
$HPLAutoReduceToMinimalSet=remember2;
Return[res]
])


S[L_List,n_]:=Switch[Length[L],
1,If[n>0,Switch[L[[1]],
plus,(1+(-1)^(n+1))/n,
minus,(1-(-1)^(n+1))/n,
_,Sign[L[[1]]]^(n+1)/n^Abs[L[[1]]]],0],
_,Switch[L[[1]],
plus,Sum[S[Delete[L,1],ii],{ii,1,n-1}]/n+(Sum[(-1)^(ii+1) S[Delete[L,1],ii],{ii,1,n-1}]/n  (-1)^n),
minus,Sum[S[Delete[L,1],ii],{ii,1,n-1}]/n-(Sum[(-1)^(ii+1) S[Delete[L,1],ii],{ii,1,n-1}]/n  (-1)^n),
0,1/n  S[Delete[L,1],n],
_,Sum[Sign[L[[1]]]^(ii+1) S[Delete[L,1],ii],{ii,1,n-1}]/n^Abs[L[[1]]]  Sign[L[[1]]]^n
]]


S2[mm_List,t_,imax_]:=(
Module[{i,nbrnull,l},Res=-1;New={};
res=Table[-1,{ii,0,Length[mm]}];
new=Table[0,{ii,0,Length[mm]}];
i=Length[mm];
nbrnull=0;
While[nbrnull<20&&i<=imax,
Res=New;
res=new;
new[[Length[mm]+1]]=1;
For[l=Length[mm],l>1,l--,
new[[l]]=res[[l]]+(Sign[mm[[l]]]^(i-l+1)/(i-l+1)^Abs[mm[[l]]]) new[[l+1]]];new[[1]]=(Sign[mm[[1]]]^i/(i^Abs[mm[[1]]])) new[[2]];
New=Append[New,new[[1]]];
i++
];
Return[SeriesData[t,0,New,Length[mm],imax+1,1]]])


HPL/:Series[HPL[mm:{__Integer},x_],{x_,0,order_Integer?Positive}]:=(
Module[{res},res=Switch[Length[mm],
1,If[mm[[1]]==0,Return[Series[Log[x],{x,0,order}]],Sum[S[mm,n] x^n,{n,1,order}]],
_,If[mm[[-1]]==0,1/(NumberOfZerosfromRight[mm]) (Log[x] Series[HPL[Delete[mm,-1],x],{x,0,order}]-Sum[Abs[mm[[j]]] Series[HPL[Delete[ReplacePart[mm,Switch[mm[[j]],_Integer?Positive,mm[[j]]+1,_Integer?Negative,mm[[j]]-1],j],-1],x],{x,0,order}],{j,1,Length[mm]-NumberOfZerosfromRight[mm]}]),(-1)^NumberOfNeg[mm] S2[HPLToZeta[mm],x,order]]
];
Return[Series[res,{x,0,order}]]]
)


HPL/:Series[HPL[mm:{(plus|0|minus)..},x_],{x_,0,order_Integer}]:=(
Module[{res,t},
res=HPLpm21m1[HPL[mm,t]];
res=res/.h_HPL:>Series[h,{t,0,order}];
Return[Series[res/.t->x,{x,0,order}]]]
)


HPL/:Series[HPL[mm:{__Integer?Positive},x_],{x_,1,order_Integer}]:=(
Module[{remember1=$HPLAutoConvertToKnownFunctions,res,t},
$HPLAutoConvertToKnownFunctions=False;
res=HPLConvertToSimplerArgument[HPL[mm,1-t]];
res=Series[res/.HPL[nn_,t]:>Series[HPL[nn,t],{t,0,order}],{t,0,order}];res=Series[res,{t,0,order}];
$HPLAutoConvertToKnownFunctions=remember1;
Return[res/.t->1-x]]
)


HPL/:Series[HPL[mm:{__Integer},x_],{x_,1,order_Integer}]:=(
Module[{res,onemx,t},
res=HPLConvertToSimplerArgument[HPL[mm,(1-t)/(1+t)]];
res=HPLLogExtract[res];
res = Collect[Expand[res], HPL[{0}, t], 
     Normal[Series[# /. 
            HPL[nn_, t] :> Series[HPL[nn, t], {t, 0, order}], {t, 0, order}]] &];
res=res/.HPL[{0},t]->Log[1-x]-Log[2]+Sum[(onemx)^j/(j 2^j),{j,1,order}];res=res/.t->Sum[(onemx)^j/2^j,{j,1,order}];
res=Collect[Expand[res],Log[1-x],Series[#,{onemx,0,order}]&]/.onemx->(1-x);
Return[res]]
)


HPL/:Series[HPL[mm:{(plus|0|minus)..},x_],{x_,1,order_Integer}]:=(
Module[{res,onemx,t},
res=HPLConvertToSimplerArgument[HPL[mm,(1-t)/(1+t)]];
res=HPLLogExtract[res];
res = Collect[Expand[res], HPL[{0}, t], 
     Normal[Series[# /. 
            HPL[nn_, t] :> Series[HPL[nn, t], {t, 0, order}], {t, 0, order}]] &];
res=res/.HPL[{0},t]->Log[1-x]-Log[2]+Sum[(onemx)^j/(j 2^j),{j,1,order}];res=res/.t->Sum[(onemx)^j/2^j,{j,1,order}];
res=Collect[Expand[res],Log[1-x],Series[#,{onemx,0,order}]&]/.onemx->(1-x);
Return[res]]
)


HPL/:Limit[HPL[mm_List,z_],z_->1]:=(
Module[{res,t},
res=HPLConvertToSimplerArgument[HPL[mm,1-t]];
res=Limit[res,t->0];
Return[res]])


SeparationPoint[1]=0.99;
SeparationPoint[2]=0.99;
SeparationPoint[3]=0.99;
SeparationPoint[4]=0.9;
SeparationPoint[5]=0.95;
SeparationPoint[6]=0.95;
SeparationPoint[w_?(#>6&)]=0.95;

nknowns={__Integer}?(Weight[#]<4&)|{n_Integer}|{1,3}|{1,1,2}|{1,2,1}|{2,2}|{3,1}|{2,1,1}|{1,1,1,1}|{-1,1,1,1}|{-1,1,-1,-1}|{-3,-1}|{-2,-1,-1}|{4,1}|{3,1,1}|x_?(ArrayQ[#,1,Function[t,t==-1]]&)|x_?(ArrayQ[#,1,Function[t,t==1]]&)|x_?(MatchQ[#,Prepend[Table[1,{j,1,Length[#]-1}],n_Integer?Positive]]&);


LE[H[1,rest__]]:=(Module[{s,t,n},
s=Split[{1,rest}];
n=Length[s[[1]]];
t=Delete[newprod[s[[1]],Flatten[Delete[s,1]]],1];
Return[1/n! (H[1]^n) LE[H@@Flatten[Delete[s,1]]]-Plus@@(LE/@Apply[H,t,{1}])]]
)


LE[HH[1,rest__]]:=(Module[{s,t,n},
s=Split[{1,rest}];
n=Length[s[[1]]];
t=Delete[newprod[s[[1]],Flatten[Delete[s,1]]],1];
Return[1/n! (HH[1]^n) LE[HH@@Flatten[Delete[s,1]]]-Plus@@(LE/@Apply[HH,t,{1}])]]
)


LE2[H[rest__,0]]:=(Module[{s,t,n},
s=Split[{rest,0}];
n=Length[s[[-1]]];
t=Delete[newprod[Flatten[Delete[s,-1]],s[[-1]]],1];
Return[1/n! (H[0]^n) H@@Flatten[Delete[s,-1]]-Plus@@(LE2/@Apply[H,t,{1}])]]
)


LE2[HH[rest__,0]]:=(Module[{s,t,n},
s=Split[{rest,0}];
n=Length[s[[-1]]];
t=Delete[newprod[Flatten[Delete[s,-1]],s[[-1]]],1];
Return[1/n! (HH[0]^n) HH@@Flatten[Delete[s,-1]]-Plus@@(LE2/@Apply[HH,t,{1}])]]
)


LE[x_]:=x
LE2[x_]:=x
HH[]:=1
H[]:=1


newint[x_Plus,a_]:=newint[#,a]&/@x
newint[x_ HH[mm__],a_]:=x newint[HH[mm],a]
newint[HH[mm__],a_]:=HH[a,mm]
newint[x_,a_]:=x HH[a]


newint[x_Plus,a_]:=newint[#,a]&/@x
newint[x_ HH[mm__],a_]:=x newint[HH[mm],a]
newint[HH[mm__],a_]:=HH[a,mm]
newint[x_,a_]:=x HH[a]


newint[HH[mm__],zero2x]:=HH[0,mm]-HZ[0,mm]
newint[x_,zero2x]:=x (HH[0]-HZ[0])


F[H[0]]:=-HH[1]-HH[-1]
F[H[1]]:=-HH[0]-HO[-1]+HH[-1]
F[H[-1]]:=-HH[-1]+HO[-1]



F[H[m_,mm___]]:=(Module[{res,res2,y},
res=Switch[m,
0,
res2=HProductExpand[F[H[mm]]];HO[m,mm]-newint[res2,1]-newint[res2,-1],
1,LE[H[m,mm]]/.xx_H:>F[xx],
-1,res2=HProductExpand[F[H[mm]]];HO[m,mm]-newint[res2,-1]	
];
Return[res]
])


Fpm[H[0]]:=-HH[plus]
Fpm[H[1]]:=-HH[0]-HO[-1]+1/2 (HH[plus]-HH[minus])
Fpm[H[-1]]:=-HH[-1]+HO[-1]
Fpm[H[plus]]:=-HH[0]
Fpm[H[minus]]:=-HH[0]+(HH[plus]-HH[minus])-2 HO[-1]


Fpm[H[m_,mm___]]:=(Module[{res,res2,rplus,rminus,y,tt},
res=Switch[m,
0,
res2=HProductExpand[Fpm[H[mm]]];HO[m,mm]-newint[res2,plus],	
plus,res2=HProductExpand[Fpm[H[mm]]];HO[m,mm]-(newint[res2,zero2x]),
minus,res2=HProductExpand[Fpm[H[mm]]];HO[m,mm]-newint[res2,zero2x]+newint[res2,plus]-newint[res2,minus]
];
Return[res//.HZ[mmm__]:>(Fpm[H[mmm]]/.{HH[mmmm__]:>HO[mmmm]})//Collect[#,_HPL]&]
])


Fpm4[H[0]]:=-HH[plus]
Fpm4[H[plus]]:=-HH[0]
Fpm4[H[minus]]:=-HH[0]+(HH[plus]-HH[minus])-2 Log[2]


Fpm4[H[m_,mm___]]:=(Module[{res,res2,rplus,rminus,y,tt},
res2=HProductExpand[Fpm4[H[mm]]];
res=Switch[m,
0,
HIU[m,mm]-((newint[res2,plus])//(#-(#/.HH->HIL))&),	
plus,HIU[m,mm]-((newint[res2,0])//(#-(#/.HH->HIL))&),
minus,HIU[m,mm]-((newint[res2,0]-newint[res2,plus]+newint[res2,minus])//(#-(#/.HH->HIL))&)
];
Return[res]])


HPL[mm:{(plus|0|minus)..},(1-x_)/(1+x_)]:=Module[{res},res=Fpm4[H@@mm]/.{HIU[mmm__]:>HPL[{mmm},I],HIL[mmm__]:>HPL[{mmm},-I],HH[mmm__]:>HPL[{mmm},x]}]/;$HPLAutoConvertToSimplerArgument


 N2[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y,res},res=LE2[H@@(HPLMtoA[mm])]/.H[0]->Log[x]//.H[mmm__]:>(-1)^NumberOfNeg[{mmm}] NHPL2[HPLToZeta[HPLAtoM[{mmm}]],x,p+Weight[mm]]/.y->x;
N[res,p]])


 N3[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=(1-x)/(1+x),res},res=F[H@@(HPLMtoA[mm])]/.HH[mmm__]:>LE2[HH[mmm]]/.HH[0]->Log[y]/.{HH[mmm__]:>(-1)^NumberOfNeg[{mmm}] NHPL2[HPLToZeta[HPLAtoM[{mmm}]],y,p+Weight[mm]],HO[mmm__]:>HPLatOne[HPLAtoM[{mmm}]]};
res=N[res,p+Weight[mm]];
N[res,p]])


 CN2[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y,res},res=LE2[H@@(HPLMtoA[mm])]/.H[0]->Log[x]//.H[mmm__]:>(-1)^NumberOfNeg[{mmm}] CNHPL[HPLToZeta[HPLAtoM[{mmm}]],x]/.y->x;
N[res,p]])


 CN3[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=(1-x)/(1+x),res},res=F[H@@(HPLMtoA[mm])]/.HH[mmm__]:>LE2[HH[mmm]]/.HH[0]->Log[y]/.{HH[mmm__]:>(-1)^NumberOfNeg[{mmm}]CNHPL[HPLToZeta[HPLAtoM[{mmm}]],y],HO[mmm__]:>HPLatOne[HPLAtoM[{mmm}]]};
N[res,p]])


 Npm2[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y,res},res=LE2[H@@(HPLMtoA[mm])]/.H[0]->Log[x]//.H[mmm__]:> NHPL3[pm2zeta[HPLAtoM[{mmm}]],x,p+Weight[mm]]/.y->x;
N[res,p]])


 Npm3[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=(1-x)/(1+x),res},res=Expand[Fpm[H@@(HPLMtoA[mm])]]/.HH[mmm__]:>LE2[HH[mmm]]/.HH[0]->Log[y];
res=res/.HO[mmm__]->HPLatOne[HPLAtoM[{mmm}]]//Expand;
res=res/.HH[mmm__]:>NHPL3[pm2zeta[HPLAtoM[{mmm}]],y,p+Weight[mm]];
res=Collect[res//Expand,_HPL];
res=N[res,p+Weight[mm]];
N[res,p]])


CNpm2[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y,res},res=LE2[H@@(HPLMtoA[mm])]/.H[0]->Log[x]//.H[mmm__]:> CNHPLpm[pm2zeta[HPLAtoM[{mmm}]],x]/.y->x;
N[res,p]])


CNpm3[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=(1-x)/(1+x),res},res=Expand[Fpm[H@@mm]]/.HH[mmm__]:>LE2[HH[mmm]];
res=res/.HO[mmm__]->HPLatOne[{mmm}]//Expand;
res=res/.HH[0]->Log[y];
res=res/.HH[mmm__]:>CNHPLpm[pm2zeta[{mmm}],y];
res=Collect[res//Expand,_HPL];
res=N[res,p+Weight[mm]];
N[res,p]])


 HPL/:HPL[mm:{__Integer}?(MatchQ[#,nknowns]&),x_Real?(NumericQ[#]&&#>0&&#<1&&Not[Precision[#]==Infinity]&),opts___Rule]:=(Module[{y,res},res=HPLConvertToKnownFunctions[HPL[mm,y]]/.y->x;
Return[res]])


 HPL/:HPL[mm:{__Integer},x_Real?NumericQ,opts___Rule]:=CN2[mm,x,Precision[x]]/;x>0&&x<SeparationPoint[Weight[mm]]&&Not[Precision[x]==Infinity]&&Precision[x]<=$MachinePrecision;


 HPL/:HPL[mm:{__Integer},x_Real?NumericQ,opts___Rule]:=CN3[mm,x,Precision[x]]/;x>=SeparationPoint[Weight[mm]]&&x<1&&Not[Precision[x]==Infinity]&&Precision[x]<=$MachinePrecision;


 HPL/:HPL[mm:{(plus|0|minus)..},x_Real?NumericQ,opts___Rule]:=CNpm2[mm,x,Precision[x]]/;x>0&&x<SeparationPoint[Weight[mm]]&&Not[Precision[x]==Infinity]&&Precision[x]<=$MachinePrecision;


 HPL/:HPL[mm_List,x_Real?NumericQ,opts___Rule]:=CNpm3[mm,x,Precision[x]]/;x>=SeparationPoint[Weight[mm]]&&x<1&&Not[Precision[x]==Infinity]&&Precision[x]<=$MachinePrecision;


 HPL/:HPL[mm:{__Integer},x_Real?NumericQ,opts___Rule]:=N2[mm,x,Precision[x]]/;x>0&&x<SeparationPoint[Weight[mm]]&&Not[Precision[x]==Infinity]


 HPL/:HPL[mm:{__Integer},x_Real?NumericQ,opts___Rule]:=N3[mm,x,Precision[x]]/;x>=SeparationPoint[Weight[mm]]&&x<1&&Not[Precision[x]==Infinity]


 HPL/:HPL[mm:{(plus|0|minus)..},x_Real?NumericQ,opts___Rule]:=Npm2[mm,x,Precision[x]]/;x>0&&x<SeparationPoint[Weight[mm]]&&Not[Precision[x]==Infinity]


 HPL/:HPL[mm_List,x_Real?NumericQ,opts___Rule]:=Npm3[mm,x,Precision[x]]/;x>=SeparationPoint[Weight[mm]]&&x<1&&Not[Precision[x]==Infinity]


 HPL/:N[HPL[mm:{__Integer},x_?(Element[#,Reals]&&Precision[#]==Infinity&&#>0&),opts___Rule],p_:$MachinePrecision]:=N2[mm,x,p]/;x<SeparationPoint[Weight[mm]]


 HPL/:N[HPL[mm:{__Integer},x_?(Element[#,Reals]&&Precision[#]==Infinity&& #<1&),opts___Rule],p_:$MachinePrecision]:= N3[mm,x,p]/;x>=SeparationPoint[Weight[mm]];


 HPL/:N[HPL[mm:{(plus|0|minus)..},x_?(Element[#,Reals]&&Precision[#]==Infinity&&#>0&),opts___Rule],p_:$MachinePrecision]:=Npm2[mm,x,p]/;x<SeparationPoint[Weight[mm]]


 HPL/:N[HPL[mm:{(plus|0|minus)..},x_?(Element[#,Reals]&&Precision[#]==Infinity&& #<1&),opts___Rule],p_:$MachinePrecision]:=Npm3[mm,x,p]/;x>=SeparationPoint[Weight[mm]]


HPL/:HPL[mm_List,x_?NumberQ,opts___Rule]:=N[HPLatOne[mm,opts],Precision[x]]/;x==1&&Not[Precision[x]==Infinity];


HPL/:N[HPL[mm_List,x_?(Element[#,Reals]&),opts___Rule],p_:$MachinePrecision]:=(Module[{res},res=HPLAutoAnalyticContinuation[mm,x,opts];
N[res,p]])/;Not[x>=0&&x<=1]&&Precision[x]==Infinity;


HPL/:HPL[mm_List,x_?(Element[#,Reals]&),opts___Rule]:=(Module[{res},res=HPLAutoAnalyticContinuation[mm,x,opts];
Return[N[res,Precision[x]]]])/;Not[x>=0&&x<1]&&Not[Precision[x]==Infinity];


HPL/:N[HPL[mm_List,x_?NumberQ,opts___Rule],p_:$MachinePrecision]:=N[HPLatOne[mm,opts],p]/;x==1&&Precision[x]==Infinity;


HPL/:HPL[mm_List,x_?NumberQ,opts___Rule]:=N[HPLAnalyticContinuation[HPL[mm,-1],opts,AnalyticContinuationRegion->m1to0],Precision[x]]/;x==-1&&Not[Precision[x]==Infinity];


NHPL2[mm_List,x_,prec_]:=(
Module[{i,nbrnull,l},Res=-1;New=0;
res=Table[-1,{ii,0,Length[mm]}];
new=Table[0,{ii,0,Length[mm]}];
i=Length[mm];
nbrnull=0;
While[nbrnull<20,
Res=New;
res=new;
new[[Length[mm]+1]]=1;
For[l=Length[mm],l>1,l--,
new[[l]]=res[[l]]+(Sign[mm[[l]]]^(i-l+1)/(i-l+1)^Abs[mm[[l]]]) new[[l+1]]];new[[1]]=res[[1]]+(x^i Sign[mm[[1]]]^i/(i^Abs[mm[[1]]])) new[[2]];
New=N[new[[1]],prec];
i++;
If[New==Res,nbrnull++,nbrnull=0]
];
Return[New]])


NHPL3[mm_List,x_,prec_]:=(
Module[{i,nbrnull,l},Res=-1;New=0;
res=Table[-1,{ii,0,Length[mm]}];
new=Table[0,{ii,0,Length[mm]}];
i=Length[mm];
nbrnull=0;
While[nbrnull<20,
Res=New;
res=new;
new[[Length[mm]+1]]=1;
For[l=Length[mm],l>1,l--,
new[[l]]=res[[l]]+((1+Sign[mm[[l]]](-1)^(i-l+1))/(i-l+1)^Abs[mm[[l]]]) new[[l+1]]];new[[1]]=res[[1]]+(x^i (1+Sign[mm[[1]]](-1)^i)/(i^Abs[mm[[1]]])) new[[2]];
New=N[new[[1]],prec];
i++;
If[New==Res,nbrnull++,nbrnull=0]
];
Return[New]])


CNHPL=Compile[{{mm,_Integer,1},{x,_Real}},
Module[{i=0.0,nbrnull=0.0,res=Table[0.0,{ii,0,Length[mm]}],new=Table[0.0,{ii,0,Length[mm]}],Res=0.0,New=0.0,zw=0.0},
i=Length[mm];
While[nbrnull<10,
Res=New;
res=new;
new[[Length[mm]+1]]=1;

For[l=Length[mm],l>1,l--,
new[[l]]=res[[l]]+(Sign[mm[[l]]]^Round[(i-l+1)]/(i-l+1)^Abs[mm[[l]]]) new[[l+1]]];
new[[1]]=res[[1]]+(x^i Sign[mm[[1]]]^Round[i]/(i^Abs[mm[[1]]])) new[[2]];
New=N[new[[1]]];
i++;
If[New==Res,nbrnull++,nbrnull=0]
];
Return[New]]
];


CNHPLpm=Compile[{{mm,_Integer,1},{x,_Real}},
Module[{i=0.0,nbrnull=0.0,l=0.0},Res=0.0;New=0.0;
res=Table[0.0,{ii,0,Length[mm]}];
new=Table[0.0,{ii,0,Length[mm]}];
i=Length[mm];
nbrnull=0.0;
While[nbrnull<20,
Res=New;
res=new;
new[[Length[mm]+1]]=1;
For[l=Length[mm],l>1,l--,
new[[l]]=res[[l]]+((1+Sign[mm[[l]]](-1)^Round[(i-l+1)])/(i-l+1)^Abs[mm[[l]]]) new[[l+1]]];new[[1]]=res[[1]]+(x^i (1+Sign[mm[[1]]](-1)^Round[i])/(i^Abs[mm[[1]]])) new[[2]];
New=N[new[[1]]];
i++;
If[New==Res,nbrnull++,nbrnull=0]
];
Return[New]]];


 N3[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=(1-x)/(1+x),res},res=F[H@@(HPLMtoA[mm])]/.HH[mmm__]:>LE2[HH[mmm]]/.HH[0]->Log[y]/.{HH[mmm__]:>(-1)^NumberOfNeg[{mmm}] NHPL2[HPLToZeta[HPLAtoM[{mmm}]],y,p+Weight[mm]],HO[mmm__]:>HPLatOne[HPLAtoM[{mmm}]]};
res=N[res,p+Weight[mm]];
N[res,p]])


 N4Complex[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=1/x,res,remember=$HPLAnalyticContinuationSign},
$HPLAnalyticContinuationSign=Sign[Im[x]];res=F3[H@@(HPLMtoA[mm])];
$HPLAnalyticContinuationSign=remember;
res=res/.HH[mmm__]:>LE2[HH[mmm]]/.HH[0]->Log[y];
res=res/.HO[mmm__]:>HPL[HPLAtoM[{mmm}],1];
res=Collect[res,_HH,Expand];
res=res/.{HH[mmm__]:>(-1)^NumberOfNeg[{mmm}]NHPL2[HPLToZeta[HPLAtoM[{mmm}]],y,p+Weight[mm]]};
N[res,p]])


N5[mm:{___Integer},ix_?NumericQ,p_:MachinePrecision]:=Module[{res,x=-I ix},res=LE2[H@@(HPLMtoA[mm])]/.H[0]-> Log[ix]//.H[mmm__]
:>numzetaix[HPLAtoM[{mmm}],x,p+Weight[mm]];
Return[N[res,p]]
]


 CN2Complex[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y,res},res=LE2[H@@(HPLMtoA[mm])]/.H[0]->Log[x]//.H[mmm__]:>(-1)^NumberOfNeg[{mmm}] CNHPLComplex[HPLToZeta[HPLAtoM[{mmm}]],x]/.y->x;
N[res,p]])


 CN3Complex[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=(1-x)/(1+x),res},res=F[H@@(HPLMtoA[mm])]/.HH[mmm__]:>LE2[HH[mmm]]/.HH[0]->Log[y]/.{HH[mmm__]:>(-1)^NumberOfNeg[{mmm}]CNHPLComplex[HPLToZeta[HPLAtoM[{mmm}]],y],HO[mmm__]:>HPLatOne[HPLAtoM[{mmm}]]};
N[res,p]])


 CN4Complex[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=1/x,res,remember=$HPLAnalyticContinuationSign},
$HPLAnalyticContinuationSign=Sign[Im[x]];res=F3[H@@(HPLMtoA[mm])];
$HPLAnalyticContinuationSign=remember;
res=res/.HH[mmm__]:>LE2[HH[mmm]]/.HH[0]->Log[y]/.{HH[mmm__]:>(-1)^NumberOfNeg[{mmm}]CNHPLComplex[HPLToZeta[HPLAtoM[{mmm}]],y],HO[mmm__]:>HPL[HPLAtoM[{mmm}],1]};
N[res,p]])


 Npm2[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y,res},res=LE2[H@@(HPLMtoA[mm])]/.H[0]->Log[x]//.H[mmm__]:> NHPL3[pm2zeta[HPLAtoM[{mmm}]],x,p+Weight[mm]]/.y->x;
N[res,p]])


 Npm3[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=(1-x)/(1+x),res},res=Expand[Fpm[H@@(HPLMtoA[mm])]]/.HH[mmm__]:>LE2[HH[mmm]]/.HH[0]->Log[y];
res=res/.HO[mmm__]->HPLatOne[HPLAtoM[{mmm}]]//Expand;
res=res/.HH[mmm__]:>NHPL3[pm2zeta[HPLAtoM[{mmm}]],y,p+Weight[mm]];
res=Collect[res//Expand,_HPL];
res=N[res,p+Weight[mm]];
N[res,p]])


Npm4[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=1/x,res},res=If[Im[x]>0,F3pmUpper[H@@mm],F3pmLower[H@@mm]];
res=res/.HH[mmm__]:>LE2[HH[mmm]];res=Expand[res];
res=res/.HO[mmm__]->HPLatOne[{mmm}]//Expand;
res=res/.HH[0]->Log[y];
res=res/.HH[mmm__]:>NHPL3[pm2zeta[{mmm}],y,p+Weight[mm]];
res=res/.{HIU[mmm__]:>HPLpm21m1[HPL[{mmm},I]],HIL[mmm__]:>HPLpm21m1[HPL[{mmm},-I]]};
res=N[res,p+Weight[mm]];
N[res,p]])


CNpm2Complex[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y,res},res=LE2[H@@(HPLMtoA[mm])]/.H[0]->Log[x]//.H[mmm__]:> CNHPLpmComplex[pm2zeta[HPLAtoM[{mmm}]],x]/.y->x;
N[res,p]])


CNpm3Complex[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=(1-x)/(1+x),res},res=Expand[Fpm[H@@mm]]/.HH[mmm__]:>LE2[HH[mmm]];
res=res/.HO[mmm__]->HPLatOne[{mmm}]//Expand;
res=res/.HH[0]->Log[y];
res=res/.HH[mmm__]:>CNHPLpmComplex[pm2zeta[{mmm}],y];
res=Collect[res//Expand,_HPL];
res=N[res,p+Weight[mm]];
N[res,p]])


CNpm4Complex[mm_List,x_?NumericQ,p_:MachinePrecision]:=(Module[{y=1/x,res},res=If[Im[x]>0,F3pmUpper[H@@mm],F3pmLower[H@@mm]];
res=res/.HH[mmm__]:>LE2[HH[mmm]];res=Expand[res];
res=res/.HO[mmm__]->HPLatOne[{mmm}]//Expand;
res=res/.HH[0]->Log[y];
res=res/.HH[mmm__]:>CNHPLpmComplex[pm2zeta[{mmm}],y];
res=res/.{HIU[mmm__]:>HPLpm21m1[HPL[{mmm},I]],HIL[mmm__]:>HPLpm21m1[HPL[{mmm},-I]]};
res=N[res,p+Weight[mm]];
N[res,p]])


FindRegion[x_?NumericQ]:=Switch[Abs[x],
_?(#<0.9&),Return[1],
_?(#>1.5&),Return[2],
_,Switch[Abs[Arg[x]],
_?(#<(5\[Pi])/12&), Return[3],
_?(#>(7\[Pi])/12&), Return[4],
_, Return[5]]
];


 HPL/:HPL[mm:{__Integer},x_Complex?(NumericQ[#]&&Precision[#]<=$MachinePrecision&),opts___Rule]:=Switch[FindRegion[x],
1,CN2Complex[mm,x,Precision[x]],
2,CN4Complex[mm,x,Precision[x]],
3,CN3Complex[mm,x,Precision[x]],
4,Module[{res,y},
res=LE2[H@@HPLMtoA[mm]];
res=res/.H[0]:>Log[x];
res=res/.H[mmm__]:>
HPLArgTransform[HPL[{mmm},y],y->-y]/.y->x;
Return[res]],
5,N5[mm,x,Precision[x]]
];


 HPL/:HPL[mm:{(plus|0|minus)..},x_Complex?(NumericQ[#]&&Precision[#]<=$MachinePrecision&),opts___Rule]:=Switch[FindRegion[x],
1,CNpm2Complex[mm,x,Precision[x]],
2,CNpm4Complex[mm,x,Precision[x]],
3,CNpm3Complex[mm,x,Precision[x]],
4,Module[{res,y},
res=LE2[H@@HPLMtoA[mm]];
res=res/.H[0]:>Log[x];
res=res/.H[mmm__]:>
HPLArgTransform[HPL[{mmm},y],y->-y]/.y->x;
Return[res]],
5,Module[{y,res},res=HPLpm21m1[mm,H];
res=res/.H[mmm__]:>N5[{mmm},x,Precision[x]+Weight[mm]];
Return[N[res,Precision[x]]];
]

];


 HPL[mm:{__Integer},x_?(NumericQ[#]&&Precision[#]<\[Infinity]&)]:=Switch[FindRegion[x],
1,N2[mm,x,Precision[x]],
2,N4Complex[mm,x,Precision[x]],
3,N3[mm,x,Precision[x]],
4,N[
Module[{res,y},
res=LE2[H@@HPLMtoA[mm]];
res=res/.H[0]:>Log[x];
res=res/.H[mmm__]:>
HPLArgTransform[HPL[{mmm},y],y->-y]/.y->x
]
,Precision[x]],
5,N5[mm,x,Precision[x]]
];


 HPL[mm:{(plus|0|minus)..},x_?(NumericQ[#]&&Precision[#]<\[Infinity]&)]:=Switch[FindRegion[x],
1,Npm2[mm,x,Precision[x]],
2,Npm4[mm,x,Precision[x]],
3,Npm3[mm,x,Precision[x]],
4,N[Module[{res,y},
res=LE2[H@@HPLMtoA[mm]];
res=res/.H[0]:>Log[x];
res=res/.H[mmm__]:>
HPLArgTransform[HPL[{mmm},y],y->-y]/.y->x
],Precision[x]],
5,Module[{y,res},res=HPLpm21m1[mm,H];
res=res/.H[mmm__]:>N5[{mmm},x,Precision[x]+Weight[mm]];
N[res,Precision[x]]
]

];


 HPL/:N[HPL[mm:{__Integer},x_?NumericQ],p_:$MachinePrecision]:=Switch[FindRegion[x],
1,N2[mm,x,p],
2,N4Complex[mm,x,p],
3,N3[mm,x,p],
4,N[
Module[{res,y},
res=LE2[H@@HPLMtoA[mm]];
res=res/.H[0]:>Log[x];
res=res/.H[mmm__]:>
HPLArgTransform[HPL[{mmm},y],y->-y]/.y->x
]
,p],
5,N5[mm,x,p]
];


 HPL/:N[HPL[mm:{(plus|0|minus)..},x_?NumericQ],p_:$MachinePrecision]:=Switch[FindRegion[x],
1,Npm2[mm,x,p],
2,Npm4[mm,x,p],
3,Npm3[mm,x,p],
4,N[Module[{res,y},
res=LE2[H@@HPLMtoA[mm]];
res=res/.H[0]:>Log[x];
res=res/.H[mmm__]:>
HPLArgTransform[HPL[{mmm},y],y->-y]/.y->x
],p],
5,Module[{y,res},res=HPLpm21m1[mm,H];
res=res/.H[mmm__]:>N5[{mmm},x,p+Weight[mm]];
N[res,p]
]

];


HPL[mm:({__Integer}|{(plus|0|minus)..}),x_?(NumericQ[#]&&Precision[#]<\[Infinity]&)]:=N[HPL[mm,x],Precision[x]]


CNHPLComplex=Compile[{{mm,_Integer,1},{x,_Complex}},
Module[{i=0.0,nbrnull=0.0,res=Table[0.0+0.0 I,{ii,0,Length[mm]}],new=Table[0.0+0.0 I,{ii,0,Length[mm]}],Res=0.0+0.0 I,New=0.0+0.0 I},
i=Length[mm];
While[nbrnull<10,
Res=New;
res=new;
new[[Length[mm]+1]]=1;

For[l=Length[mm],l>1,l--,
new[[l]]=res[[l]]+(Sign[mm[[l]]]^Round[(i-l+1)]/(i-l+1)^Abs[mm[[l]]]) new[[l+1]]];
new[[1]]=res[[1]]+(x^i Sign[mm[[1]]]^Round[i]/(i^Abs[mm[[1]]])) new[[2]];
New=N[new[[1]]];
i++;
If[New==Res,nbrnull++,nbrnull=0]
];
Return[New]]
];


CNHPLpmComplex=Compile[{{mm,_Integer,1},{x,_Complex}},
Module[{i=0.0,nbrnull=0.0,l=0.0},Res=0.0+0.0 I;New=0.0+0.0 I;
res=Table[0.0+0.0 I,{ii,0,Length[mm]}];
new=Table[0.0+0.0 I,{ii,0,Length[mm]}];
i=Length[mm];
nbrnull=0.0;
While[nbrnull<20,
Res=New;
res=new;
new[[Length[mm]+1]]=1;
For[l=Length[mm],l>1,l--,
new[[l]]=res[[l]]+((1+Sign[mm[[l]]](-1)^(i-l+1))/(i-l+1)^Abs[mm[[l]]]) new[[l+1]]];new[[1]]=res[[1]]+(x^i (1+Sign[mm[[1]]](-1)^Round[i])/(i^Abs[mm[[1]]])) new[[2]];
New=N[new[[1]]];
i++;
If[New==Res,nbrnull++,nbrnull=0]
];
Return[New]]];


newint[x_Plus,a_]:=newint[#,a]&/@x
newint[x_ HH[mm__],a_]:=x newint[HH[mm],a]
newint[HH[mm__],a_]:=HH[a,mm]
newint[x_,a_]:=x HH[a]


T3[H[0]]:=-HH[1]
T3[H[1]]:=-HH[0]
T3[H[m_,mm___]]:=(Module[{res,res2,y},
res2=HProductExpand[T3[H[mm]]];
res=Switch[m,
0,HO[m,mm]-newint[res2,1],
1,LE[H[m,mm]]/.xx_H:>T3[xx]
];
Return[res]
])


F[H[0]]:=-HH[1]-HH[-1]
F[H[1]]:=-HH[0]-HO[-1]+HH[-1]
F[H[-1]]:=-HH[-1]+HO[-1]



F[H[m_,mm___]]:=(Module[{res,res2,y},
res=Switch[m,
0,
res2=HProductExpand[F[H[mm]]];HO[m,mm]-newint[res2,1]-newint[res2,-1],
1,LE[H[m,mm]]/.xx_H:>F[xx],
-1,res2=HProductExpand[F[H[mm]]];HO[m,mm]-newint[res2,-1]	
];
Return[res]
])


F2[H[0]]:=HH[1]+HH[0];
F2[H[1]]:=-HH[1]


F2[H[m_,mm___]]:=Module[{res,res2},
If[NumberOfZerosfromRight[{m,mm}]>=1,res=LE2[H[m,mm]]/.H[xx__]:>F2[H[xx]];Return[res]];
res=Switch[m,
0,res2=HProductExpand[F2[H[mm]]];res=newint[res2,1]+newint[res2,0],
1,LE[H[m,mm]]]/.H[xx__]:>F2[H[xx]];
Return[res]
]


F3[H[0]]:=-HH[0]
F3[H[1]]:=HH[1]+HH[0]+HPL[{0},-1];
F3[H[-1]]:=HH[-1]-HH[0];


F3[H[m_,mm___]]:=(Module[{res,res2,y},
res=Switch[m,
0,((newint[HProductExpand[F3[H[mm]]],0])//((#/.HH->HO)-#&))+HO[m,mm],
1,LE[H[m,mm]]/.xx_H:>F3[xx],
-1,res2=HProductExpand[F3[H[mm]]];((newint[res2,0]-newint[res2,-1])//((#/.HH->HO)-#&))+HO[m,mm]
];
Return[res]
])


F3pmUpper[H[0]]:=-HH[0]
F3pmUpper[H[plus]]:=HH[plus]+I \[Pi];
F3pmUpper[H[minus]]:=HH[minus]+2 HH[0]+I \[Pi];


F3pmLower[H[0]]:=-HH[0]
F3pmLower[H[plus]]:=HH[plus]-I \[Pi];
F3pmLower[H[minus]]:=HH[minus]+2 HH[0]-I \[Pi];


F3pm\[Delta][H[0]]:=-HH[0]
F3pm\[Delta][H[plus]]:=HH[plus]+$HPLAnalyticContinuationSign I \[Pi];
F3pm\[Delta][H[minus]]:=HH[minus]+2 HH[0]+$HPLAnalyticContinuationSign I \[Pi];


F3pmUpper[H[m_,mm___]]:=(Module[{res,res2,y,\[Delta],remember},
res=Switch[m,
0,((newint[HProductExpand[F3pmUpper[H[mm]]],0])//((#/.HH->HIL)-#&))+HIU[m,mm],
plus,
res2=HProductExpand[F3pmUpper[H[mm]]];
HIU[m,mm]+(#-(#/.HH->HIL)&)[newint[res2,plus]],
minus,res2=HProductExpand[F3pmUpper[H[mm]]];
    HIU[m,mm]-((#/.HH->HIL)-#&)[newint[res2,minus]+2 newint[res2,0]]
];
Return[res]
])


F3pmLower[H[m_,mm___]]:=(Module[{res,res2,y,\[Delta],remember},
res=Switch[m,
0,((newint[HProductExpand[F3pmLower[H[mm]]],0])//((#/.HH->HIU)-#&))+HIL[m,mm],
plus,
res2=HProductExpand[F3pmLower[H[mm]]];
HIL[m,mm]+(#-(#/.HH->HIU)&)[newint[res2,plus]],
minus,res2=HProductExpand[F3pmLower[H[mm]]];
    HIL[m,mm]-((#/.HH->HIU)-#&)[newint[res2,minus]+2 newint[res2,0]]
];
Return[res]
])


F3pm\[Delta][H[m_,mm___]]:=(Module[{res,res2,y,\[Delta],remember},
res=Switch[m,
0,((newint[HProductExpand[F3pm\[Delta][H[mm]]],0])//((#/.HH->HIm\[Delta])-#&))+HI\[Delta][m,mm],
plus,
res2=HProductExpand[F3pm\[Delta][H[mm]]];
HI\[Delta][m,mm]+(#-(#/.HH->HIm\[Delta])&)[newint[res2,plus]],
minus,res2=HProductExpand[F3pm\[Delta][H[mm]]];
    HI\[Delta][m,mm]-((#/.HH->HIm\[Delta])-#&)[newint[res2,minus]+2 newint[res2,0]]
];
Return[res]
])


HPLIRule={HIL[plus]->-\[Pi] I/2,HIU[plus]->\[Pi] I/2,HI\[Delta][plus]->\[Delta] \[Pi] I/2,HIm\[Delta][plus]->-\[Delta] \[Pi] I/2,HIU[minus]->-Log[2],HIL[minus]->-Log[2],HI\[Delta][minus]->-Log[2],HIm\[Delta][minus]->-Log[2],HIU[0]->I \[Pi]/2,HIL[0]->-I \[Pi]/2,HI\[Delta][0]->\[Delta] I \[Pi]/2,HIm\[Delta][0]->-\[Delta] I \[Pi]/2,h:HIU[(plus)..]:>(\[Pi] I/2)^Length[h]/(Length[h]!),h:HIL[(plus)..]:>(-\[Pi] I/2)^Length[h]/(Length[h]!),h:HI\[Delta][(plus)..]:>(\[Delta] \[Pi] I/2)^Length[h]/(Length[h]!),h:HIm\[Delta][(plus)..]:>(-\[Delta] \[Pi] I/2)^Length[h]/(Length[h]!),h:HIU[(minus)..]:>(-Log[2])^Length[h]/(Length[h]!),h:HIL[(minus)..]:>(-Log[2])^Length[h]/(Length[h]!),h:HI\[Delta][(minus)..]:>(-Log[2])^Length[h]/(Length[h]!),h:HIm\[Delta][(minus)..]:>(-Log[2])^Length[h]/(Length[h]!),h:HIU[(0)..]:>(\[Pi] I/2)^Length[h]/(Length[h]!),h:HIL[(0)..]:>(-\[Pi] I/2)^Length[h]/(Length[h]!),h:HI\[Delta][(0)..]:>(\[Delta] \[Pi] I/2)^Length[h]/(Length[h]!),h:HIm\[Delta][(0)..]:>(-\[Delta] \[Pi] I/2)^Length[h]/(Length[h]!),HIL[plus,0]->-\[Pi]^2/4+2 I Catalan,HIU[plus,0]->-\[Pi]^2/4-2 I Catalan,HI\[Delta][plus,0]->-\[Pi]^2/4-\[Delta] 2 I Catalan,HIm\[Delta][plus,0]->-\[Pi]^2/4+\[Delta] 2 I Catalan,HIU[0,plus]->I 2 Catalan,HIL[0,plus]->-2  I Catalan,HI\[Delta][0,plus]->\[Delta] 2  I Catalan,HIm\[Delta][0,plus]->-\[Delta] 2  I Catalan,HIU[0,minus]->-\[Pi]^2/24,HIL[0,minus]->-\[Pi]^2/24,HI\[Delta][0,minus]->-\[Pi]^2/24,HIm\[Delta][0,minus]->-\[Pi]^2/24,HIU[minus,0]->\[Pi]^2/24-I Log[2] \[Pi]/2,HIL[minus,0]->\[Pi]^2/24+I Log[2] \[Pi]/2,HI\[Delta][minus,0]->\[Pi]^2/24-\[Delta] I Log[2] \[Pi]/2,HIm\[Delta][minus,0]->\[Pi]^2/24+\[Delta] I Log[2] \[Pi]/2};


HPL\[Delta]I[mm:{(plus|0|minus)..},\[Delta]_]:=(1+\[Delta])/2 HPL[mm,I]+(1-\[Delta])/2 HPL[mm,-I]//HPLProductExpand


HPLArgTransform[h:HPL[{__},_],r_Rule,opts___]:=Switch[r[[2]],
Evaluate[_?(FreeQ[#,r[[1]]]&)],Message[HPLArgTransform::BadRule,r];h,
-r[[1]],HPLArgTransform[h,1,opts],
Evaluate[Sqrt[r[[1]]]],HPLArgTransform[h,2,opts],
Evaluate[1-r[[1]]],HPLArgTransform[h,3,opts],
Evaluate[(1-r[[1]])/(1+r[[1]])],HPLArgTransform[h,4,opts],
Evaluate[r[[1]]/(r[[1]]-1)],HPLArgTransform[h,5,opts],
Evaluate[1/r[[1]]],HPLArgTransform[h,6,opts],
_,Message[HPLArgTransform::UnKnownRule,r];h
]


HPLArgTransform[x_,r_Rule,opts___]:=x/.h:HPL[{__},_]:>HPLArgTransform[h,r,opts];


HPLArgTransform[(H|HPL)[mm:{___Integer,_Integer?Positive|_Integer?Negative},x_],1,\[Delta]_:$HPLAnalyticContinuationSign]:=(-1)^Length[mm] HPL[-mm,-x]


HPLArgTransform[(H|HPL)[mm:{(plus|0|minus)...,(plus|minus)},x_],1,\[Delta]_:$HPLAnalyticContinuationSign]:=(-1)^Length[Cases[mm,plus]] HPL[mm,-x]


HPLArgTransform[(H|HPL)[mm:{___Integer,0},x_],1,\[Delta]_:$HPLAnalyticContinuationSign]:=Module[{res},res=LE2[H@@HPLMtoA[mm]];
res=res/.H[0]->HPL[{0},-x]+I \[Pi] \[Delta];
res=res/.H[mmm__]:>HPLArgTransform[HPL[{mmm},x],1,\[Delta]]]


HPLArgTransform[(H|HPL)[mm:{(plus|0|minus)...,0},x_],1,\[Delta]_:$HPLAnalyticContinuationSign]:=Module[{res},res=LE2[H@@mm];
res=res/.H[0]->HPL[{0},-x]+\[Delta] I \[Pi];
res=res/.H[mmm__]:>(-1)^Length[Cases[{mmm},plus]] HPL[{mmm},-x]]


HPLArgTransform[x_,1,___]:=x


HPLArgTransform[(H|HPL)[{0},x_],2,\[Delta]_:$HPLAnalyticContinuationSign]:=2 HPL[{0},Sqrt[x]]
HPLArgTransform[HPL[{1},x_],2,\[Delta]_:$HPLAnalyticContinuationSign]:=HPL[{1},Sqrt[x]]-HPL[{-1},Sqrt[x]]


HPLArgTransform[(H|HPL)[mm:{__Integer?NonNegative},x_],2,\[Delta]_:$HPLAnalyticContinuationSign]:=
HPLpm21m1[HPL[(HPLMtoA[mm])/.(1->minus),Sqrt[x]] 2^Count[HPLMtoA[mm],0]]


HPLArgTransform[(H|HPL)[mm:{___,(_?Negative|plus|minus),___},x_],2,___]:=(Message[HPLArgTransform::WrongWeight,x->Sqrt[x],mm];HPL[mm,x])


HPLArgTransform[x_,2,___]:=x


HPLArgTransform[(H|HPL)[{0},x_],3,\[Delta]_:$HPLAnalyticContinuationSign]:=-HPL[{1},1-x]
HPLArgTransform[(H|HPL)[{1},x_],3,\[Delta]_:$HPLAnalyticContinuationSign]:=-HPL[{0},1-x]


HPLArgTransform[(H|HPL)[mm:{__Integer?NonNegative},x_],3,\[Delta]_:$HPLAnalyticContinuationSign]:=Module[{res},res=T3[H@@(HPLMtoA[mm])]/.{HO[mmm__]:>HPLatOne[HPLAtoM[{mmm}]],HH[mmm__]->HPL[{mmm},1-x]}]//HPLProductExpand


HPLArgTransform[(H|HPL)[mm:{___,(_?Negative|plus|minus),___},x_],3,___]:=(Message[HPLArgTransform::WrongWeight,x->1-x,mm];HPL[mm,x])


HPLArgTransform[x_,3,___]:=x


HPLArgTransform[(H|HPL)[{0},x_],4,\[Delta]_:$HPLAnalyticContinuationSign]:=-HPL[{1},(1-x)/(1+x)]-HPL[{-1},(1-x)/(1+x)]
HPLArgTransform[(H|HPL)[{1},x_],4,\[Delta]_:$HPLAnalyticContinuationSign]:=-HPL[{0},(1-x)/(1+x)]-Log[2]+HPL[{-1},(1-x)/(1+x)]
HPLArgTransform[(H|HPL)[{-1},x_],4,\[Delta]_:$HPLAnalyticContinuationSign]:=-HPL[{-1},(1-x)/(1+x)]+Log[2]


HPLArgTransform[(H|HPL)[mm:{__Integer},x_],4,\[Delta]_:$HPLAnalyticContinuationSign]:=Module[{res},res=F[H@@(HPLMtoA[mm])];res=res/.{HH[mmm__]->HPL[{mmm},(1-x)/(1+x)],HO[mmm__]:>HPLatOne[HPLAtoM[{mmm}]]};Return[res//HPLProductExpand]]


HPLArgTransform[(H|HPL)[mm:{(plus|0|minus)..},x_],4,\[Delta]_:$HPLAnalyticContinuationSign]:=Module[{res},res=Fpm4[H@@mm]/.{HIU[mmm__]:>HPL[{mmm},I],HIL[mmm__]:>HPL[{mmm},-I],HI\[Delta][mmm__]:>HPL\[Delta]I[{mmm},\[Delta]],HIm\[Delta][mmm__]:>HPL\[Delta]I[{mmm},-\[Delta]],HH[mmm__]:>HPL[{mmm},(1-x)/(1+x)]};Return[res//HPLProductExpand]]


HPLArgTransform[x_,4,___]:=x


HPLArgTransform[(H|HPL)[{0},x_],5,\[Delta]_:$HPLAnalyticContinuationSign]:=HPL[{1},x/(x-1)]+HPL[{0},x/(x-1)]+\[Delta] I \[Pi]
HPLArgTransform[(H|HPL)[{1},x_],5,\[Delta]_:$HPLAnalyticContinuationSign]:=-HPL[{1},x/(x-1)]


HPLArgTransform[(H|HPL)[mm:{__Integer?Positive},x_],5,\[Delta]_:$HPLAnalyticContinuationSign]:=Module[{res,y},
res=F2[H@@(HPLMtoA[mm])];
Return[res/.HH[xx__]:>HPL[{xx},x/(x-1)]]//HPLProductExpand]


HPLArgTransform[(H|HPL)[mm:{__Integer?NonNegative,0},x_],5,\[Delta]_:$HPLAnalyticContinuationSign]:=Module[{res,y},
res=LE2[H@@HPLMtoA[mm]];
res=res/.H[0]:>HPL[{1},x/(x-1)]+HPL[{0},x/(x-1)]+\[Delta] I \[Pi];
res=res/.H[mmm__]:>F2[H[mmm]];
Return[res/.HH[xx__]:>HPL[{xx},x/(x-1)]]//HPLProductExpand]


HPLArgTransform[(H|HPL)[mm:{___,(_?Negative|plus|minus),___},x_],5,___]:=(Message[HPLArgTransform::WrongWeight,x->x/(x-1),mm];HPL[mm,x])


HPLArgTransform[x_,5,___]:=x


T6[H[0],\[Delta]_]:=-HH[0]
T6[H[1],\[Delta]_]:=HH[1]+HH[0]+\[Delta] I \[Pi];
T6[H[-1],\[Delta]_]:=HH[-1]-HH[0];


T6[H[m_,mm___],\[Delta]_]:=(Module[{res,res2,y},
res=Switch[m,
0,((newint[HProductExpand[T6[H[mm],\[Delta]]],0])//((#/.HH->HO)-#&))+HO[m,mm],
1,LE[H[m,mm]]/.xx_H:>T6[xx,\[Delta]],
-1,res2=HProductExpand[T6[H[mm],\[Delta]]];((newint[res2,0]-newint[res2,-1])//((#/.HH->HO)-#&))+HO[m,mm]
];
Return[res]
])


T6pm[H[0],\[Delta]_]:=-HH[0]
T6pm[H[plus],\[Delta]_]:=HH[plus]+\[Delta] I \[Pi];
T6pm[H[minus],\[Delta]_]:=HH[minus]+2 HH[0]+\[Delta] I \[Pi];


T6pm[H[m_,mm___],\[Delta]_]:=(Module[{res,res2,y,remember},
res=Switch[m,
0,((newint[HProductExpand[T6pm[H[mm],\[Delta]]],0])//((#/.HH->HIm\[Delta])-#&))+HI\[Delta][m,mm],
plus,
res2=HProductExpand[T6pm[H[mm],\[Delta]]];
HI\[Delta][m,mm]+(#-(#/.HH->HIm\[Delta])&)[newint[res2,plus]],
minus,res2=HProductExpand[T6pm[H[mm],\[Delta]]];
    HI\[Delta][m,mm]-((#/.HH->HIm\[Delta])-#&)[newint[res2,minus]+2 newint[res2,0]]
];
Return[res]
])


HPLArgTransform[(H|HPL)[{0},x_],6,\[Delta]_:$HPLAnalyticContinuationSign]:=-HPL[{0},1/x]
HPLArgTransform[(H|HPL)[{1},x_],6,\[Delta]_:$HPLAnalyticContinuationSign]:=HPL[{1},1/x]+HPL[{0},1/x]+\[Delta] I \[Pi]
HPLArgTransform[(H|HPL)[{-1},x_],6,\[Delta]_:$HPLAnalyticContinuationSign]:=HPL[{-1},1/x]-HPL[{0},1/x]


HPLArgTransform[(H|HPL)[mm:{__Integer},x_],6,\[Delta]_:$HPLAnalyticContinuationSign]:=Module[{res},res=T6[H@@(HPLMtoA[mm]),\[Delta]]/.{HO[mmm__]:>HPLatOne[HPLAtoM[{mmm}]],HH[mmm__]->HPL[{mmm},1/x]}//HPLProductExpand]


HPLArgTransform[(H|HPL)[mm:{(plus|0|minus)..},x_],6,\[Delta]_:$HPLAnalyticContinuationSign]:=Module[{res},res=T6pm[H@@mm,\[Delta]]/.{HI\[Delta][mmm__]:>HPL\[Delta]I[{mmm},\[Delta]],HIm\[Delta][mmm__]:>HPL\[Delta]I[{mmm},-\[Delta]],HH[mmm__]:>HPL[{mmm},1/x]};
res//HPLProductExpand]


HPLArgTransform[x_,6,___]:=x


match1={mm:({__Integer}|{(plus|0|minus)..}),x:(-_|_?(Element[#,Reals]&&#<0&&#>-1&))}


HPLConvertToSimplerArgument[HPL[Sequence@@match1,___DoArgConvert]]:=Module[{y},HPLArgTransform[H[mm,-y],1]/.y->-x]


match2={mm:{__Integer?NonNegative},x_^2}


HPLConvertToSimplerArgument[HPL[Sequence@@match2,___DoArgConvert]]:=Module[{y},HPLArgTransform[H[mm,y],2,$HPLAnalyticContinuationSign]/.\[Sqrt]y->x/.y->x^2]


match3={mm:{__Integer?NonNegative},1-x_}


HPLConvertToSimplerArgument[HPL[Sequence@@match3,___DoArgConvert]]:=Module[{y},HPLArgTransform[H[mm,1-y],3,$HPLAnalyticContinuationSign]/.y->x]


match4={mm:({(plus|0|minus)..}|{__Integer}),(1-x_)/(1+x_)}


HPLConvertToSimplerArgument[HPL[Sequence@@match4,___DoArgConvert]]:=Module[{y},HPLArgTransform[H[mm,y],4,$HPLAnalyticContinuationSign]/.(1-y)/(1+y)->x/.y->(1-x)/(x+1)]


match5={mm:{___Integer?NonNegative,_Integer?Positive},x_/(x_-1)}


HPLConvertToSimplerArgument[HPL[Sequence@@match5,___DoArgConvert]]:=Module[{y},HPLArgTransform[H[mm,y],5,$HPLAnalyticContinuationSign]/.(y)/(y-1)->x/.y->x/(x-1)]


match6={mm:({__Integer}|{(plus|0|minus)..}),1/x_}


HPLConvertToSimplerArgument[HPL[mm:({__Integer}|{(plus|0|minus)..}),1/x_,___DoArgConvert]]:=Module[{y},HPLArgTransform[H[mm,1/y],6,$HPLAnalyticContinuationSign]/.y->x]


HPLConvertToSimplerArgument[x_]:=x/.h_HPL:>HPLConvertToSimplerArgument[h]


HPLConvertToSimplerArgument[h_HPL]:=h


toconvert=match1|match2|match3|match4|match5|match6


HPL[mm_List,x_]:=HPLConvertToSimplerArgument[HPL[mm,x,DoArgConvert[]]]/;MatchQ[{mm,x},toconvert]&&$HPLAutoConvertToSimplerArgument


Options[HPLAnalyticContinuation]:={AnalyticContinuationSign->$HPLAnalyticContinuationSign,AnalyticContinuationRegion->Automatic};


HPLAnalyticContinuation[HPL[mm:{__Integer},x_],opts___Rule]:=(
Module[{\[Delta],trans,t,u,xx,res,remember1,remember2,remember3,remember4},
remember1=$HPLAutoProductExpand;
remember2=$HPLAutoConvertToKnownFunctions;
remember3=$HPLAutoConvertToSimplerArgument;

$HPLAutoProductExpand=False;
$HPLAutoConvertToKnownFunctions=False;
$HPLAutoConvertToSimplerArgument=False;
\[Delta]=AnalyticContinuationSign/.{opts}/.Options[HPLAnalyticContinuation];
trans=AnalyticContinuationRegion/.{opts}/.Options[HPLAnalyticContinuation];
Switch[trans,
Automatic,
Return[HPLAutoAnalyticContinuation[mm,x,opts]],
m1to0,
res=HPLLogExtract[HPL[mm,t]];
res=res/.HPL[{0},t]->HPL[{0},-x]+\[Delta] I \[Pi];
res=res/.HPL[mmm_List,t]:>(HPLConvertToSimplerArgument[HPL[mmm,-u]]/.u->-x);
$HPLAutoProductExpand=remember1;
$HPLAutoConvertToKnownFunctions=remember2;
$HPLAutoConvertToSimplerArgument=remember3;
Return[res],
minftom1,
res=HPLLogExtractMinus1[HPL[mm,t]];
res=res/.HPL[{0},t]->-HPL[{0},-1/x]+\[Delta] I \[Pi];
res=res/.HPL[{-1},t]->I \[Pi] \[Delta]-HPL[{0},-1/x]-HPL[{1},-1/x];
res=res/.HPL[mmm_List,t]:>HPLAnalyticContinuation[HPLConvertToSimplerArgument[HPL[mmm,-u]]/.u->-x,AnalyticContinuationSign->-\[Delta],AnalyticContinuationRegion->onetoinf];
$HPLAutoProductExpand=remember1;
$HPLAutoConvertToKnownFunctions=remember2;
Return[res],
onetoinf,
remember4=$HPLAnalyticContinuationSign;
$HPLAnalyticContinuationSign=\[Delta];
res=HPLConvertToSimplerArgument[HPL[mm,1/t]];
$HPLAnalyticContinuationSign=remember4;
$HPLAutoProductExpand=remember1;
$HPLAutoConvertToKnownFunctions=remember2;
Return[res/.t->1/x],
_,Message[HPLAutoAnalyticContinuation::wrongoption];Return[HPL[mm,x]]
]
])


HPLAnalyticContinuation[HPL[mm:{(plus|0|minus)..},x_],opts___Rule]:=(
Module[{\[Delta],trans,t,u,xx,res,remember1,remember2,remember3,remember4,remember\[Delta]},
remember1=$HPLAutoProductExpand;
remember2=$HPLAutoConvertToKnownFunctions;
remember3=$HPLAutoConvertToSimplerArgument;
remember\[Delta]=$HPLAnalyticContinuationSign;
$HPLAutoProductExpand=False;
$HPLAutoConvertToKnownFunctions=False;
$HPLAutoConvertToSimplerArgument=False;

\[Delta]=AnalyticContinuationSign/.{opts}/.Options[HPLAnalyticContinuation];
trans=AnalyticContinuationRegion/.{opts}/.Options[HPLAnalyticContinuation];
Switch[trans,
Automatic,
Return[HPLAutoAnalyticContinuation[mm,x,opts]],
m1to0,
$HPLAnalyticContinuationSign=\[Delta];
res=(HPLArgTransform[HPL[mm,u],u->-u,\[Delta]]);
$HPLAnalyticContinuationSign=remember\[Delta];
$HPLAutoProductExpand=remember1;
$HPLAutoConvertToKnownFunctions=remember2;
$HPLAutoConvertToSimplerArgument=remember3;
Return[res/.u->x],
minftom1,
res=HPLLogExtractMinus1[HPL[mm,t]];
res=res/.HPL[{0},t]->-HPL[{0},-1/x]+\[Delta] I \[Pi];
res=res/.HPL[{-1},t]->I \[Pi] \[Delta]-HPL[{0},-1/x]-HPL[{1},-1/x];
res=res/.HPL[mmm_List,t]:>HPLAnalyticContinuation[HPLConvertToSimplerArgument[HPL[mmm,-u]]/.u->-x,AnalyticContinuationSign->-\[Delta],AnalyticContinuationRegion->onetoinf];
$HPLAutoProductExpand=remember1;
$HPLAutoConvertToKnownFunctions=remember2;
Return[res],
onetoinf,
remember4=$HPLAnalyticContinuationSign;
$HPLAnalyticContinuationSign=\[Delta];
res=HPLConvertToSimplerArgument[HPL[mm,1/t]];
$HPLAnalyticContinuationSign=remember4;
$HPLAutoProductExpand=remember1;
$HPLAutoConvertToKnownFunctions=remember2;
Return[res/.t->1/x],
_,Message[HPLAutoAnalyticContinuation::wrongoption];Return[HPL[mm,x]]
]
])


HPLAnalyticContinuation[x_,opts___Rule]:=x/.HPL[mm_List,y_]:>HPLAnalyticContinuation[HPL[mm,y],opts]


SetAttributes[HPLAutoAnalyticContinuation,NHoldFirst]


HPLAutoAnalyticContinuation[mm_List,x:(_Rational?(#<0&&#>=-1&)|_Real?(#<0&&#>=-1&)|x_?(!MatchQ[#,_. _Complex]&&NumericQ[#]&&#<0&&#>=-1&)),opts___Rule]:=(Module[{res,y},
res=HPLAnalyticContinuation[HPL[mm,y],AnalyticContinuationRegion->m1to0,opts];
Return[res/.y->x]
])


HPLAutoAnalyticContinuation[mm_List,x_?(Element[#,Reals]&&NumericQ[#]&&#<-1&),opts___Rule]:=(Module[{res,y},
res=HPLAnalyticContinuation[HPL[mm,y],AnalyticContinuationRegion->minftom1,opts];
Return[res/.y->x]
])


HPLAutoAnalyticContinuation[mm_List,x:(_Rational?(#>1&)|_Real?(#>1&)|_?(!MatchQ[#,_. _Complex]&&NumericQ[#]&&#>1&)),opts___Rule]:=(Module[{res,y},
res=HPLAnalyticContinuation[HPL[mm,y],AnalyticContinuationRegion->onetoinf,opts];
Return[res/.y->x]
])


HPLAutoAnalyticContinuation[mm_List,x_,opts___Rule]:=HPL[mm,x]


HPL[mm_List,0|0.,opts___Rule]:=0/;Not[MatchQ[mm,Table[0,{j,1,Length[mm]}]]]
HPL[mm_List,1,opts___Rule]:=HPLatOne[mm,opts]/;Not[MatchQ[mm,{1}]]


HPL[mm:{___Integer,0},-1]:=Block[{t},HPLArgTransform[HPL[mm,t],x->-x,$HPLAnalyticContinuationSign]/.t->-1]/;Not[MatchQ[mm,{-1}]]
HPL[mm:{(_Integer)..},-1,opts___Rule]:=Block[{t},HPLArgTransform[HPL[mm,t],x->-x,$HPLAnalyticContinuationSign]/.t->-1]/;Not[MatchQ[mm,{-1}]]

HPL[mm:{(plus|0|minus)...,0},-1]:=Block[{t},HPLArgTransform[HPL[mm,t],x->-x,$HPLAnalyticContinuationSign,Reals]/.t->-1]
HPL[mm:{(plus|0|minus)..},-1,opts___Rule]:=Block[{t},HPLArgTransform[HPL[mm,t],x->-x]/.t->-1]


HPLatOne[{-1},opts___Rule]:=Log[2]
HPLatOne[{0},opts___Rule]:=0
HPLatOne[{1},opts___Rule]:=ComplexInfinity


NumberOfNeg[L_]:=Apply[Plus,If[#<0,1,0]&/@L]
ConstructHPLVector[mm_List]:=Module[{res,ii},
res={mm[[1]]};
For[ii=2,ii<=Length[mm],ii++,res=Append[res,mm[[ii]] Sign[res[[ii-1]]]]];
Return[res]
]


HPLToZeta[mm_List]:=Prepend[Table[mm[[jj]] Sign[mm[[jj-1]]],{jj,2,Length[mm]}],mm[[1]]]
pm2zeta[{plus}]:={-1}
pm2zeta[{minus}]:={1}
pm2zeta[{0}]:={0}
pm2zeta[{plus,ll__}]:=Prepend[#,-Sign[#[[1]]]]&[pm2zeta[{ll}]]
pm2zeta[{minus,ll__}]:=Prepend[#,Sign[#[[1]]]]&[pm2zeta[{ll}]]
pm2zeta[{0,ll__}]:=ReplacePart[#,#[[1]]+Sign[#[[1]]],1]&[pm2zeta[{ll}]]
pm2zeta[{0,plus,0,0,minus}]


(*Get[ToFileName[{$HPLPath},"h6table.mat"]]
Get[ToFileName[{$HPLPath},"h7table.mat"]]
Get[ToFileName[{$HPLPath},"h8table.mat"]]*)

MaxMZVTables:=Module[{ii},For[ii=6,ii<=10,ii++,If[FileType[ToFileName[{$HPLPath},"h"<>ToString[ii]<>"table.mat"]]==None,Return[ii-1]]]]

$MaxMZVTables=MaxMZVTables
Print["Table of MZVs loaded up to weight "<>ToString[$MaxMZVTables]];
Module[{ii},For[ii=6,ii<=$MaxMZVTables,ii++,Get[ToFileName[{$HPLPath},"h"<>ToString[ii]<>"table.mat"]]]]

HPLatOne[mm_List,opts___Rule]:=MZV[mm]/;ArrayQ[mm,1,Positive]


HPLatOne[mm_List,opts___Rule]:=(-1)^NumberOfNeg[mm] MZV[HPLToZeta[mm]]/;ArrayQ[mm,1,#!=0&]


HPLatOne[mm:{_Integer..,0},opts___Rule]:=
	1/(NumberOfZerosfromRight[mm]) (-Sum[Abs[mm[[j]]] HPLatOne[Delete[ReplacePart[mm,Switch[mm[[j]],_Integer?Positive,mm[[j]]+1,_Integer?Negative,mm[[j]]-1],j],-1]],{j,1,Length[mm]-NumberOfZerosfromRight[mm]}])/;Length[mm]>=2





HPLatOne[{n_Integer?Negative},opts___Rule]:=(1-2^(1+n)) Zeta[-n]/;n<-1


HPLatOne[mm:{___,plus|minus,___}]:=HPLpm21m1[mm,HPL[{##},1]&]


SetAttributes[HPLI,NHoldAll]


MaxHPLatITables:=Module[{ii},For[ii=2,ii<=10,ii++,If[FileType[ToFileName[{$HPLPath},"HPLatI"<>ToString[ii]<>".m"]]==None,Return[ii-1]]]]

$MaxHPLatITables=MaxHPLatITables

Module[{ii},For[ii=1,ii<=$MaxHPLatITables,ii++,Get[ToFileName[{$HPLPath},"HPLatI"<>ToString[ii]<>".m"]]]];
Module[{ii},For[ii=4,ii<=$MaxHPLatITables,ii++,Get[ToFileName[{$HPLPath},"numHPLatI"<>ToString[ii]<>".m"]]]]Print["Table of values at I loaded up to weight "<>ToString[$MaxHPLatITables]];


HPL[mm:{(plus|0|minus)...},-I]:=Module[{res},res=LE2[H@@mm];
res=res/.H[0]->-I \[Pi]/2;
res=res/.H[mmm__]:>(-1)^Length[Cases[{mmm},plus]] HPL[{mmm},I];
res=res//HPLProductExpand
]


HPL[{plus},I]:=\[Pi] I/2;
HPL[{plus},-I]:=-\[Pi] I/2;
HPL[{plus},$HPLAnalyticContinuationSign I]:=$HPLAnalyticContinuationSign \[Pi] I/2;
HPL[{plus},-$HPLAnalyticContinuationSign I]:=-$HPLAnalyticContinuationSign \[Pi] I/2;


HPL[{minus},I|-I|$HPLAnalyticContinuationSign I|-$HPLAnalyticContinuationSign I]:=-Log[2];


HPL[{0},I]:=\[Pi] I/2;
HPL[{0},-I]:=-\[Pi] I/2;
HPL[{0},$HPLAnalyticContinuationSign I]:=$HPLAnalyticContinuationSign \[Pi] I/2;
HPL[{0},-$HPLAnalyticContinuationSign I]:=-$HPLAnalyticContinuationSign \[Pi] I/2;


HPL[mm:{(plus)..},I]:=(\[Pi] I/2)^Length[mm]/(Length[mm])!;
HPL[mm:{(plus)..},-I]:=(-\[Pi] I/2)^Length[mm]/(Length[mm])!;
HPL[mm:{(plus)..},$HPLAnalyticContinuationSign I]:=($HPLAnalyticContinuationSign \[Pi] I/2)^Length[mm]/(Length[mm])!;
HPL[mm:{(plus)..},-$HPLAnalyticContinuationSign I]:=(-$HPLAnalyticContinuationSign \[Pi] I/2)^Length[mm]/(Length[mm])!;


HPL[mm:{(0)..},I]:=(\[Pi] I/2)^Length[mm]/(Length[mm])!;
HPL[mm:{(0)..},-I]:=(-\[Pi] I/2)^Length[mm]/(Length[mm])!;
HPL[mm:{(0)..},$HPLAnalyticContinuationSign I]:=($HPLAnalyticContinuationSign \[Pi] I/2)^Length[mm]/(Length[mm])!;
HPL[mm:{(0)..},-$HPLAnalyticContinuationSign I]:=(-$HPLAnalyticContinuationSign \[Pi] I/2)^Length[mm]/(Length[mm])!;


HPL[mm:{(minus)..},I|-I|$HPLAnalyticContinuationSign I|-$HPLAnalyticContinuationSign I]:=(-Log[2])^Length[mm]/(Length[mm])!;


HPL[mm:{(minus|0)..,minus},(I|-I)]:=2^(-Count[mm,0])Expand[HPL[(mm/.minus->1),-1]]


HPL[mm:{(minus|0)..,0},pmI:(I|-I)]:=Expand[(H@@(mm/.minus->1)//LE2)/.{H[0]:>HPL[{0},pmI],H[mmm__]:>2^(-Count[{mmm},0]) HPL[{mmm},-1]}]


HPL[mm:{(0)..,plus},I]:=I 2^(1-2 Length[mm]) (Zeta[Length[mm],1/4]-Zeta[Length[mm],3/4])


HPL[mm:{(_Integer|plus|minus)..},I]:=Module[{t},HPLReduceToMinimalSet[HPL[mm,t]]/.HPL[mmm_,t]:>HPLI[HPLMtoA[mmm]]]


N[HPLI[mm:{(_Integer|plus|minus)..}],p_:MachinePrecision]:=N5[mm,I,p]


HPLI[mm:{___,_Integer?(#>1&)|_Integer?(#<-1&),___}]:=HPLI[HPLMtoA[mm]]


MZV[mm_List]:=MZV[HPLAtoM[mm]]/;MatchQ[mm,{___,0,___,(_?Positive | _?Negative),___}]

MEx[mm_List]:=Table[Prepend[mm[[2]][[jj]],mm[[1]]],{jj,1,Length[mm[[2]]]}]
MEx[mm_List]:={{mm[[1]]}}/;Length[mm[[2]]]==0
ZProd[n_]:=Apply[Join,Table[MEx[{j,ZProd[n-j]}],{j,1,n}]]
ZProd[0]:=1

NumberOfIn[a_,L_]:=Apply[Plus,If[MatchQ[a,#],1,0]&/@L]
MZVf[L_,n_]:=Table[NumberOfIn[j,L],{j,1,n}]
MZVg[n_]:=MZVf[#,n]&/@Union[Sort/@ZProd[n]]
MZVl[L_List,n_]:=Product[1/L[[j]]! (-PolyLog[j,(-1)^j]/j)^L[[j]],{j,1,n}]
MZVk[n_]:=(-1)^n Apply[Plus,MZVl[#,n]&/@MZVg[n]]


MZV[{1}]:=HPL[{1},1];
MZV[{m_Integer?Positive}]:=Zeta[m]
MZV[{m_Integer?Negative}]:=2^m (2-2^-m) Zeta[-m]
MZV[{4,2}]:=Zeta[3]^2-4 Pi^6/2835
MZV[mm_List]:=Zeta[Length[mm]+1]/;MatchQ[mm,Prepend[Table[1,{ii,1,Length[mm]-1}],2]]
MZV[mm_List]:=MZV[{Length[mm]+1,1}]/;MatchQ[mm,Prepend[Table[1,{ii,1,Length[mm]-1}],3]]&&Length[mm]>2
MZV[mm_List]:=2 (2 Pi)^(2 Length[mm])/(2 Length[mm]+1)! (1/2)^(2 Length[mm]+1)/;MatchQ[mm,Table[2,{ii,1,Length[mm]}]]
MZV[mm_List]:=2 Pi^(2 Length[mm])/(2 Length[mm]+2)!/;MatchQ[mm,Table[If[EvenQ[ii],1,3],{ii,1,Length[mm]}]]&&Length[mm]>2&&EvenQ[Length[mm]]
MZV[{m1_Integer,1}]:=m1/2 Zeta[m1+1]-1/2 Sum[Zeta[k+1] Zeta[m1-k],{k,1,m1-2}]/;m1>2

MZV[mm_List]:=Simplify[4 (2 Pi)^(4 Length[mm])/(4 Length[mm]+2)! (1/2)^(2 Length[mm]+1)]/;MatchQ[mm,Table[4,{ii,1,Length[mm]}]]

MZV[mm_List]:=Simplify[6(2 Pi)^(6 Length[mm])/(6 Length[mm]+3)!]/;MatchQ[mm,Table[6,{ii,1,Length[mm]}]]

MZV[mm_List]:=Simplify[8 (2 Pi)^(8 Length[mm])/(8 Length[mm]+4)! ((1+1/Sqrt[2])^(4 Length[mm]+2)+(1-1/Sqrt[2])^(4Length[mm]+2))]/;MatchQ[mm,Table[8,{ii,1,Length[mm]}]]
MZV[mm_List]:=2^-(Length[mm]-1) Sum[(-1)^k MZV[Table[4,{kk,1,(Length[mm]-1)/2-k}]]((4 k+1) Zeta[4 k+2]-4 Sum[Zeta[4 jj-1] Zeta[4 k-4 jj+3],{jj,1,k}]),{k,0,(Length[mm]-1)/2}]/;MatchQ[mm,Prepend[Table[If[EvenQ[ii],3,1],{ii,1,(Length[mm]-1)}],2]]&&Length[mm]>2&&OddQ[Length[mm]]

MZV[mm_List]:=(-1)^Length[mm] (Log[2]^Length[mm])/Length[mm]!/;MatchQ[mm,Prepend[Table[1,{jj,2,Length[mm]}],-1]]&&Length[mm]>1
MZV[mm_List]:=-PolyLog[Length[mm],1/2]/;MatchQ[mm,Join[{-1,-1},Table[1,{jj,3,Length[mm]}]]]&&Length[mm]>2

MZV[mm_List]:=Simplify[Pi^(2 Length[mm])/(2 Length[mm]+1)! (-1)^(Length[mm](Length[mm]+1)/2)/2^Length[mm]]/;MatchQ[mm,Table[-2,{ii,1,Length[mm]}]]

MZV[mm_List]:=Simplify[Pi^(4 Length[mm])/(4 Length[mm]+2)! (-1)^(Length[mm](Length[mm]+1)/2)/2^Length[mm] ((1+Sqrt[2])^(2 Length[mm]+1)+(1-Sqrt[2])^(2 Length[mm]+1))]/;MatchQ[mm,Table[-4,{ii,1,Length[mm]}]]

MZV[mm_List]:=Simplify[Pi^(6 Length[mm])/(6 Length[mm]+3)! 3/2 (1+2^(3 Length[mm]+1) (-1)^(Length[mm](Length[mm]+1)/2) (((1+Sqrt[3])/2)^(6 Length[mm]+3)+((1-Sqrt[3])/2)^(6 Length[mm]+3)-1))]/;MatchQ[mm,Table[-6,{ii,1,Length[mm]}]]
MZV[mm_List]:=MZVk[Length[mm]]/;MatchQ[mm,Table[-1,{ii,1,Length[mm]}]]

(* This is equ 31 of the HL1 paper *)
MZV[mm_List]:=(-1)^NumberOfNeg[ConstructHPLVector[mm]] HPLatOne[ConstructHPLVector[mm]]/;Weight[mm]<=$MaxMZVTables



StoZinOne=V[before___,Zsum[n1_,x1_],Ssum[n2_,x2_],rest___]->V[before,Zsum[n1,x1],Zsum[n2,x2],rest]+V[before,Zsum[n1+n2,x1*x2],rest]


ZtoSinOne=V[before___,Ssum[n1_,x1_],Zsum[n2_,x2_],rest___]->V[before,Ssum[n1,x1],Ssum[n2,x2],rest]-V[before,Ssum[n1+n2,x1*x2],rest]


MyStoZinOne[x_]:=x/.V1_V:>(Ssum[Abs[#],Sign[#]]&/@V1)/.V[S1_Ssum,rest___]:>V[Zsum@@S1,rest]//.StoZinOne/.Zsum[n_,s_]:>n s


MyZtoSinOne[x_]:=x/.V1_V:>(Zsum[Abs[#],Sign[#]]&/@V1)/.V[Z1_Zsum,rest___]:>V[Ssum@@Z1,rest]//.ZtoSinOne/.Ssum[n_,s_]:>n s


SprodinOne=V[dabord___,P[V[Ssum[n1_,x1_],rest1___],V[Ssum[n2_,x2_],rest2___]]]->V[dabord,Ssum[n1,x1],P[V[rest1],V[Ssum[n2,x2],rest2]]]+V[dabord,Ssum[n2,x2],P[V[Ssum[n1,x1],rest1],V[rest2]]]-V[dabord,Ssum[n1+n2,x1 x2],P[V[rest1],V[rest2]]]


SetAttributes[P,Orderless]


V/:V1_V V2_V:=V[P[(Ssum[Abs[#],Sign[#]]&/@V1),(Ssum[Abs[#],Sign[#]]&/@V2)]]//.SprodinOne/.P[V[w___],V[]]:>w/.Ssum[n_,x_]:>n x


V/:(V1_V)^e_ :=Times@@Table[V1,{ii,1,e}]


F[x__]:=Module[{n},
n=NumberOfOnesfromLeft[{x}];
theones=Table[1,{ii,1,n}];
therest=Table[{x}[[ii]],{ii,n+1,Length[{x}]}];
Return[-(Expand[Times@@(V/@theones)/n! V@@therest]-V[x])+Times@@(HHPPLL[1,#]&/@theones)/n! V@@therest]
]


HPLINONE[mm__]:=((-1)^NumberOfNeg[{mm}]V@@(HPLToZeta[{mm}])/.V1_V:>MyZtoSinOne[V1]//.V[x:(1)..,rest___]:>F[x,rest]/.V1_V:>MyStoZinOne[V1]/.V[y__]:>(-1)^NumberOfNeg[ConstructHPLVector[{y}]]HPL[ConstructHPLVector[{y}],1]/.V[]->1/.HHPPLL->(HPL[{#1},#2]&)//Simplify)/;{mm}[[-1]]!=0


HPLINONE[mm__]:=Module[{res},res=LE2[H@@(HPLMtoA[{mm}])]/.H[0]->0;
res=res/.H[mmm__]:>HPLINONE@@(HPLAtoM[{mmm}]);
Return[res]]/;{mm}[[-1]]==0


MZV[mm_List]:=(-1)^NumberOfNeg[ConstructHPLVector[mm]] HPLINONE@@(ConstructHPLVector[mm])/;mm[[1]]==1


MZV[mm_List]:=(Module[{res,remember1,remember2,remember3},
remember1=$HPLAutoConvertToKnownFunctions;
remember2=$HPLAutoProductExpand;
remember3=$HPLAutoReduceToMinimalSet;
$HPLAutoConvertToKnownFunctions=False;
	$HPLAutoProductExpand=False;
$HPLAutoReduceToMinimalSet=False;res=Simplify[HPLLogExtract[HPL[mm,t]]/.HPL[{1},t]->Sinf/.t->1];
$HPLAutoConvertToKnownFunctions=remember1;
$HPLAutoProductExpand=remember2;
$HPLAutoReduceToMinimalSet=remember3;
Return[res]
])/;mm[[1]]==1


GG[{},x_]:=1


ff[GG[mm_List]]:=Sum[(-1)^j GG[Table[2-2 mm[[k]],{k,j,1,-1}],1] GG[Table[2 mm[[k]],{k,j+1,Length[mm]}],1],{j,0,Length[mm]}]


\[Lambda]2[mm_List,xx_List,prec_]:=Module[{Res,res,new,New,l},
Res=-1;New=0;
res=Table[-1,{ii,0,Length[mm]}];
new=Table[0,{ii,0,Length[mm]}];
nbrz=0;
i=Length[mm];
While[nbrz<20,
If[Res==New,nbrz++];
Res=New;
res=new;
new[[Length[mm]+1]]=If[i>=Length[mm],1,0];
For[l=Length[mm],l>1,l--,
new[[l]]=res[[l]]+(Sign[mm[[l]]]^(i-l+1) xx[[l]]^(i-l+1)/(i-l+1)^Abs[mm[[l]]]) new[[l+1]]];new[[1]]=res[[1]]+(Sign[mm[[1]]]^i xx[[1]]^i/(i^Abs[mm[[l]]])) new[[2]];
New=N[new[[1]],prec];
i++
];
Return[New]]


tom[mm_List]:=Module[{exp,xx,xxx,l},
exp={1};
If[MatchQ[#,0],exp=ReplacePart[exp,exp[[Length[exp]]]+1,Length[exp]],exp=Append[exp,1]]&/@mm;
exp=Delete[exp,-1];
xx=Cases[mm,x_?(#!=0&)];
xxx={1/xx[[1]]};
For[l=2,l<=Length[xx],l++,xxx=Append[xxx,xx[[l-1]]/xx[[l]]]];
Return[{exp,xxx}]]


GtoLi[GG[mm_List,1]]:=(
arg=tom[mm];
ll[arg[[1]],arg[[2]]] (-1)^Length[arg[[1]]]
)
GtoLi[x_]:=x


numzeta[mm_List,prec_]:=(-1)^Length[mm]GtoLi//@ff[GG[HPLMtoA[ConstructHPLVector[mm]]]]/.ll[x___]->\[Lambda]2[x,prec+Weight[mm]]


numzeta[{1},prec_]:=N[-Log[0]]


MZV/:N[MZV[mm_List],prec_]:=numzeta[mm,prec+Weight[mm]/2]/;mm[[1]]!=1


(* Loads precalculated values of the constants *)

Get[ToFileName[{$HPLPath},"nmzv.m"]];

HPLs6/:N[HPLs6,p_:$MachinePrecision]:=N[appHPLs6,p]/;p<=1000
HPLs7a/:N[HPLs7a,p_:$MachinePrecision]:=N[appHPLs7a,p]/;p<=1000
HPLs7b/:N[HPLs7b,p_:$MachinePrecision]:=N[appHPLs7b,p]/;p<=1000
HPLs8a/:N[HPLs8a,p_:$MachinePrecision]:=N[appHPLs8a,p]/;p<=1000
HPLs8b/:N[HPLs8b,p_:$MachinePrecision]:=N[appHPLs8b,p]/;p<=1000
HPLs8c/:N[HPLs8c,p_:$MachinePrecision]:=N[appHPLs8c,p]/;p<=1000
HPLs8d/:N[HPLs8d,p_:$MachinePrecision]:=N[appHPLs8d,p]/;p<=1000

(* For higher precision *)

HPLs6/:N[HPLs6,p_:$MachinePrecision]:=N[numzeta[{-5,-1},p+5]+numzeta[{6},p+5],p];
HPLs7a/:N[HPLs7a,p_:$MachinePrecision]:=N[numzeta[{-5,1,1},p+5]+numzeta[{-6,1},p+5]+numzeta[{-5,2},p+5]+numzeta[{-7},p+5],p];
HPLs7b/:N[HPLs7b,p_:$MachinePrecision]:=N[numzeta[{5,-1,-1},p+5]+numzeta[{-6,-1},p+5]+numzeta[{5,2},p+5]+numzeta[{7},p+5],p];
HPLs8a/:N[HPLs8a,p_:$MachinePrecision]:=N[numzeta[{8},p+5]+numzeta[{5,3},p+5],p];
HPLs8b/:N[HPLs8b,p_:$MachinePrecision]:=N[numzeta[{8},p+5]+numzeta[{-7,-1},p+5],p];
HPLs8c/:N[HPLs8c,p_:$MachinePrecision]:=N[numzeta[{8},p+5]+numzeta[{-7,-1},p+5]+numzeta[{-5,-3},p+5]+numzeta[{6,2},p+5]+numzeta[{-5,-1,2},p+5]+numzeta[{-5,2,-1},p+5]+numzeta[{6,-1,-1},p+5]+numzeta[{-5,-1,-1,-1},p+5],p];
HPLs8d/:N[HPLs8d,p_:$MachinePrecision]:=N[numzeta[{8},p+5]+numzeta[{7,1},p+5]+numzeta[{-5,-3},p+5]+numzeta[{6,2},p+5]+numzeta[{-5,-1,2},p+5]+numzeta[{-5,-2,1},p+5]+numzeta[{6,1,1},p+5]+numzeta[{-5,-1,1,1},p+5],p];
Sinf=HPL[{1},1];
(*Sinf/:N[Sinf,p_]:=Infinity;*)





NHPLI[mm:{__Integer},x_,prec_]:=(
Module[{i,nbrnull,l,res,new,imag,real},Res=-1;New=0;
real=0;
imag=0;
res=Table[-1,{ii,0,Length[mm]}];
new=Table[0,{ii,0,Length[mm]}];
i=Length[mm];
nbrnull=0;
While[nbrnull<20,
Res=New;
res=new;
new[[Length[mm]+1]]=1;
For[l=Length[mm],l>1,l--,
new[[l]]=res[[l]]+(Sign[mm[[l]]]^(i-l+1)/(i-l+1)^Abs[mm[[l]]]) new[[l+1]]];If[EvenQ[i],real=real+(x^i (I)^(i)/(i^Abs[mm[[1]]])) new[[2]],
imag=imag+(x^i (I)^(i-1) Sign[mm][[1]]^i/(i^Abs[mm[[1]]])) new[[2]]
];
New=N[real+I imag,prec];
i++;
If[New==Res,nbrnull++,nbrnull=0]
];
Return[New]])



N[HPL[mm_List,ix:(Complex[(0|0.),_?NumericQ]|_?NumericQ Complex[0,_?NumericQ])],p_:MachinePrecision]:=(Module[{y,res,s,x=-I ix},
res=LE2[H@@(HPLMtoA[mm])]/.H[0]->Sign[x] I \[Pi]/2+Log[Abs[x]]//.H[mmm__]:>(-1)^NumberOfNeg[{mmm}] NHPLI[HPLToZeta[HPLAtoM[{mmm}]],x,p+Weight[mm]]/.y->x;
N[res,p]])/;Abs[-I ix]<0.5


N[ HPL[mm_List,ix:(Complex[(0|0.),_?NumericQ]|_?NumericQ| Complex[0,_?NumericQ])],p_:MachinePrecision]:=(Module[{y,s,res,remember,x=-I ix},
remember=$HPLAnalyticContinuationSign;
$HPLAnalyticContinuationSign=Sign[x];
res=F3[H@@(HPLMtoA[mm])];
$HPLAnalyticContinuationSign=remember;
res=res/.{HO[mmm__]:>HPLatOne[HPLAtoM[{mmm}]],HH[mmm__]:>N[HPL[{mmm},Complex[0,-1/x]],p+Weight[mm]]}
])/;Abs[-I ix]>1.95

N[HPL[mm:{___,0},ix:(Complex[(0|0.),_?NumericQ]|_?NumericQ Complex[0,_?NumericQ])],p_:MachinePrecision]:=Module[{res,x=-I ix},res=LE2[H@@(HPLMtoA[mm])]/.H[0]->Sign[x] I \[Pi]/2+Log[Abs[x]]//.H[mmm__]
:>N[HPL[{mmm},ix]]
]/;Abs[-I ix]>=1/2&&Abs[-I ix]<=1.95

N[HPL[mm_List,ix:(Complex[(0|0.),_?NumericQ]|_?NumericQ Complex[0,_?NumericQ])],p_:MachinePrecision]:=(Module[{res,x=-I ix},
res=numzetaix[mm,x,p+Weight[mm]];
N[res,p]])/;Abs[-I ix]>=1/2&&Abs[-I ix]<=1.95/;Not[MatchQ[mm[[-1]],0]]


ffi[GG[mm_List]]:=Sum[(-1)^j GG[Table[2+(2 I mm[[k]]),{k,j,1,-1}],1] GG[Table[2 (-I) mm[[k]],{k,j+1,Length[mm]}],1],{j,0,Length[mm]}]


numzetai[mm_List,prec_]:=(-1)^Length[mm]GtoLi//@ffi[GG[HPLMtoA[ConstructHPLVector[mm]]]]/.ll[x___]->\[Lambda]2[x,prec+Weight[mm]]


ffix[GG[mm_List],x_]:=Sum[(-1)^j GG[Table[2+(2 I/x mm[[k]]),{k,j,1,-1}],1] GG[Table[2 (-I/x) mm[[k]],{k,j+1,Length[mm]}],1],{j,0,Length[mm]}]


numzetaix[mm_List,x_,prec_]:=(-1)^NumberOfNeg[mm] (-1)^Length[mm]GtoLi//@ffix[GG[HPLMtoA[mm]],x]/.ll[xx___]->\[Lambda]2[xx,prec+Weight[mm]]


ypart/:ypart[j1_,k1_,y___] ypart[j2_,k2_,y___]:=ypart[j1+j2,k1+k2,y]


ypart/:ypart[j1_,k1_,y___]^exp_:=ypart[exp j1,exp k1,y]


ypartrule=Module[{k,j},ypart[j_,k_,y_:y]:>y^j/(1-y^2)^k];


ypart0[j_Integer?Positive,k_]:=0;
ypart0[j_,k_]:=Module[{t},(ypart[j,k,t]/.ypartrule//Apart)/.t^(_Integer?Negative)->0/.t->0]


Clear[LL]


LL[j_Integer?Positive,Log,y_:y]:=1/(j+1)(-ypart[j+1,0,y] HH[minus]+(HH[plusorminus[j]]-Sum[(1+(-1)^(l+j+1)) ypart[l,0,y]/l,{l,1,j+1}]))


LL[0,Log,y_:y]:=-2 ypart[1,0,y]-ypart[1,0,y] HH[minus]+HH[plus]


LL[j_Integer?Negative,Log,y_:y]:=1/(j+1)(ypart[j+1,0,y] (-HH[minus])+(1+(-1)^(-j-1)) HH[0]+(HH[plusorminus[j]]+Sum[(1+(-1)^(l)) ypart[l+j+1,0,y]/(l+j+1),{l,1,-j-2}]))


LL[0,k_Integer?(#>1&),y_:y]:=1/2/(k-1)(ypart[-1,k-1,y]+LL[-2,k-2,y]+LL[0,k-1,y])


LL[1,k_Integer?(#>1&),y_:y]:=1/2/(k-1)(ypart[0,k-1,y]-1)


LL[j_Integer,k_Integer?(#>1&),y_:y]:=1/2/(k-1)(ypart[j-1,k-1,y]-ypart0[j-1,k-1]-(j-1) LL[j-2,k-1,y])


LL[j_Integer,1,y_:y]:=-1/2 (ypart[j-1,0,y] (-HH[minus])-(j-1) LL[j-2,Log,y])


LL[-1,0,y_:y]:=HH[0]


LL[j_Integer,0,y_:y]:=1/(j+1)ypart[j+1,0,y]


LL[-1,1,y_:y]:=HH[minus]/2+HH[0]


LL[1,1,y_:y]:=HH[minus]/2


LL[0,1,y_:y]:=HH[plus]/2


LL[-1,Log,y_:y]:=-HH[0,minus]


LL[j_,k_Integer?Negative,y_:y]:=Sum[Binomial[-k,kk] (-1)^kk  LL[j+2 kk,0,y],{kk,0,-k}]


Clear[myint]


myint[p_Plus]:=myint/@p


myint[ypart[j_,k_,y_:y] HH[mm__],jadd_:0]:=II[j+jadd,k,{mm}]
myint[ypart[j_,k_,y_:y],jadd_:0]:=LL[j+jadd,k,y]


myint[coeff___ ypart[j_,k_,y_:y] HH[mm__],jadd_:0]:=coeff II[j+jadd,k,{mm}]
myint[coeff___ ypart[j_,k_,y_:y],jadd_:0]:=coeff LL[j+jadd,k,y]


myint[coeff___ ypart[j_,k_,y_:y],jadd_:0]:=coeff LL[j+jadd,k,y]


myint[coeff___ HH[plus]]:=coeff (ypart[1,0,y] HH[plus]-2 myint[ypart[1,1,y]])
myint[coeff___ HH[minus]]:= coeff (ypart[1,0,y] HH[minus]-2 myint[ypart[2,1,y]])
myint[coeff___ HH[0]]:=coeff (ypart[1,0,y] HH[0]-ypart[1,0,y])


myint[coeff___ HH[plus,mm__]]:=coeff (ypart[1,0,y] HH[plus,mm]-2 myint[ypart[1,1,y]  HH[mm]])
myint[coeff___ HH[minus,mm__]]:=coeff (ypart[1,0,y] HH[minus,mm]-2 myint[ypart[2,1,y] HH[mm]])
myint[coeff___ HH[0,mm__]]:=coeff (ypart[1,0,y] HH[0,mm]-myint[HH[mm]])


Clear[II]


LLHPL0[j_Integer?Negative,k_,mm_List]:=Module[{t},SeriesCoefficient[(Apart[LL[j,k,t]/.ypart[jj_,kk_,y_:y]:>ypart[jj,kk,t]/.ypartrule,t] /.HH[0]->0)(Series[HPL[mm,t],{t,0,-j}]/.{HPL[{0},t]->0,Log[t]->0})//Expand,0]]


LLHPL0[j_Integer?NonNegative,k_,mm_List]:=0


II[0,1,{mm__}]:=HH[plus,mm]/2
II[1,1,{mm__}]:=HH[minus,mm]/2
II[-1,0,{mm__}]:=HH[0,mm]


II[j_Integer,k_Integer,{plus}]:=LL[j,k] HH[plus]-LLHPL0[j,k,{plus}]-myint[LL[j,k] 2 ypart[0,1,y]//HProductExpand]
II[j_Integer,k_Integer,{minus}]:=LL[j,k] HH[minus]-LLHPL0[j,k,{minus}]-myint[LL[j,k] 2 ypart[1,1,y]//HProductExpand]
II[j_Integer,k_Integer,{0}]:=LL[j,k] HH[0]-LLHPL0[j,k,{0}]-myint[LL[j,k] ypart[-1,0,y]//HProductExpand]


II[j_Integer,k_Integer,{plus,mm__}]:=LL[j,k,y] HH[plus,mm]-LLHPL0[j,k,{plus,mm}]-myint[LL[j,k,y] 2 ypart[0,1,y] HH[mm]//HProductExpand]
II[j_Integer,k_Integer,{minus,mm__}]:=LL[j,k] HH[minus,mm]-LLHPL0[j,k,{minus,mm}]-myint[LL[j,k] 2 ypart[1,1,y] HH[mm]//HProductExpand]
II[j_Integer,k_Integer,{0,mm__}]:=LL[j,k] HH[0,mm]-LLHPL0[j,k,{0,mm}]-myint[LL[j,k] ypart[-1,0,y] HH[mm]//HProductExpand]


II[j_Integer,k_Integer,{sq,mm__}]:=LL[j,k] HH[sq,mm]-myint[LL[j,k] ypart[0,1/2,y] HH[mm]//HProductExpand]


II[j_Integer,k_Integer,{sq2,mm__}]:=LL[j,k] HH[sq2,mm]-myint[LL[j,k] ypart[-1,1/2,y] HH[mm]//HProductExpand]


internHPLInt[j_Integer,k_Integer,x_]:=LL[j,k]/.ypartrule/.HH[mmm__]:>HPL[{mmm},x]/.y->x//Expand


internHPLInt1mx[j_Integer,k_Integer,x_]:=Sum[Binomial[k,jj] LL[j+jj,k],{jj,0,k}]/.ypartrule/.HH[mmm__]:>HPL[{mmm},x]/.y->x//Expand


internHPLInt1px[j_Integer,k_Integer,x_]:=Sum[Binomial[k,jj] (-1)^jj LL[j+jj,k],{jj,0,k}]/.ypartrule/.HH[mmm__]:>HPL[{mmm},x]/.y->x//Expand


internHPLInt[j_Integer,k_Integer,mm:{(plus|minus|0)..},x_]:=Collect[II[j,k,mm]/.HH[mmm__]:>HPL[{mmm},x]/.ypartrule/.y->x//HPLProductExpand,_HPL,Simplify]


internHPLInt[j_Integer,k_Integer,mm:{__Integer},x_]:= Collect[HPL1m12pm[mm,II[j,k,{##}]&]/.HH[mmm__]:>HPL[{mmm},x]/.ypartrule/.y->x//HPLProductExpand//HPLpm21m1,_HPL,Simplify]


internHPLInt1px[j_Integer,k_Integer,mm:{(plus|minus|0)..},x_]:=Collect[Sum[Binomial[k,jj] (-1)^jj II[j+jj,k,mm],{jj,0,k}]/.HH[mmm__]:>HPL[{mmm},x]/.ypartrule/.y->x//HPLProductExpand,_HPL,Simplify]


internHPLInt1mx[j_Integer,k_Integer,mm:{(plus|minus|0)..},x_]:=Collect[Sum[Binomial[k,jj]II[j+jj,k,mm],{jj,0,k}]/.HH[mmm__]:>HPL[{mmm},x]/.ypartrule/.y->x//HPLProductExpand,_HPL,Simplify]


internHPLInt1px[j_Integer,k_Integer,mm:{__Integer},x_]:=Collect[Sum[Binomial[k,jj] (-1)^jj HPL1m12pm[mm,II[j+jj,k,{##}]&],{jj,0,k}]/.HH[mmm__]:>HPL[{mmm},x]/.ypartrule/.y->x//HPLpm21m1//HPLProductExpand,_HPL,Simplify]


internHPLInt1mx[j_Integer,k_Integer,mm:{__Integer},x_]:=Collect[Sum[Binomial[k,jj] HPL1m12pm[mm,II[j+jj,k,{##}]&],{jj,0,k}]/.HH[mmm__]:>HPL[{mmm},x]/.ypartrule/.y->x//HPLpm21m1//HPLProductExpand,_HPL,Simplify]


HPLInt[coeff___ (x_)^(i_Integer:1) (1-(x_)^2)^(j_Integer:1) HPL[ll:{(plus|0|minus|_Integer)..},x_],x_]:=coeff internHPLInt[i,-j,ll,x]/;FreeQ[{coeff},x]


HPLInt[coeff___  (1-(x_)^2)^(j_Integer:1) HPL[ll:{(plus|minus|_Integer)..},x_],x_]:=coeff internHPLInt[0,-j,ll,x]/;FreeQ[{coeff},x]


HPLInt[coeff___ (x_)^(i_Integer:1) (1-(x_)^2)^(j_Integer:1) ,x_]:=coeff internHPLInt[i,-j,x]/;FreeQ[{coeff},x]


HPLInt[coeff___  (1-(x_)^2)^(j_Integer:1) ,x_]:=coeff internHPLInt[0,-j,x]/;FreeQ[{coeff},x]


HPLInt[coeff___ (x_)^(i_Integer:1) (1-x_)^(j_Integer?Negative) HPL[ll:{(plus|0|minus|_Integer)..},x_],x_]:=coeff internHPLInt1mx[i,-j,ll,x]/;FreeQ[{coeff},x]


HPLInt[coeff___  (1-x_)^(j_Integer?Negative) HPL[ll:{(plus|minus|_Integer)..},x_],x_]:=coeff internHPLInt1mx[0,-j,ll,x]/;FreeQ[{coeff},x]


HPLInt[coeff___ (x_)^(i_Integer:1) (1-x_)^(j_Integer?Negative) ,x_]:=coeff internHPLInt1mx[i,-j,x]/;FreeQ[{coeff},x]


HPLInt[coeff_.  (1-x_)^(j_Integer?Negative) ,x_]:=coeff internHPLInt1mx[0,-j,x]/;FreeQ[{coeff},x]


HPLInt[coeff___ (x_)^(i_Integer:1) (1+x_)^(j_Integer?Negative) HPL[ll:{(plus|0|minus|_Integer)..},x_],x_]:=coeff internHPLInt1px[i,-j,ll,x]/;FreeQ[{coeff},x]


HPLInt[coeff___  (1+x_)^(j_Integer?Negative) HPL[ll:{(plus|minus|_Integer)..},x_],x_]:=coeff internHPLInt1px[0,-j,ll,x]/;FreeQ[{coeff},x]


HPLInt[coeff___ (x_)^(i_Integer:1) (1+x_)^(j_Integer?Negative) ,x_]:=coeff internHPLInt1px[i,-j,x]/;FreeQ[{coeff},x]


HPLInt[coeff_.  (1+x_)^(j_Integer?Negative) ,x_]:=coeff internHPLInt1px[0,-j,x]/;FreeQ[{coeff},x]


HPLInt[coeff___   HPL[ll:{(plus|minus|_Integer)..},x_],x_]:=coeff internHPLInt[0,0,ll,x]/;FreeQ[{coeff},x]


HPLInt[HPL[ll:{(plus|minus|_Integer)..},x_],x_]:=internHPLInt[0,0,ll,x]


HPLInt[coeff___ (x_)^(i_Integer:1)  HPL[ll:{(plus|minus|_Integer)..},x_],x_]:=coeff internHPLInt[i,0,ll,x]/;FreeQ[{coeff},x]


HPLInt[coeff___ (x_)^(i_Integer:1),x_]:=coeff internHPLInt[i,0,x]/;FreeQ[{coeff},x]


HPLInt[ (x_)^(i_Integer:1),x_Symbol]:=internHPLInt[i,0,x]/;FreeQ[{coeff},x]


HPLInt[p_Plus,y_Symbol]:=HPLInt[#,y]&/@p


HPLInt[c_,y_Symbol]:=c y/;FreeQ[c,y]


HPLInt/:D[HPLInt[expr_,y_],y_]:=expr


(*$HPLConservative=False*)
$HPLAutoLogExtract=False
$HPLAutoConvertToKnownFunctions=False
$HPLAutoProductExpand=False
$HPLAutoReduceToMinimalSet=False
$HPLAutoConvertToSimplerArgument=False
(* Since Mathematica seems to use this convention *)
$HPLAnalyticContinuationSign=1


SetAttributes[HPL,{NHoldFirst,NumericFunction,Protected,ReadProtected}]
SetAttributes[
{HPLMtoA,HPLAtoM,HPLLogExtract,HPLConvertToKnownFunctions,HPLProductExpand,HPLConvertToSimplerArgument,HPLpm21m1,HPL1m12pm},
{Protected,ReadProtected}]


SetAttributes[HPLAnalyticContinuation,{NHoldFirst,Protected,ReadProtected}]
SetAttributes[MZV,{NHoldFirst,NumericFunction,Protected,ReadProtected}]
SetAttributes[HPLInt,{NHoldAll,Protected,ReadProtected}]
SetAttributes[HPLArgTransform,{NHoldAll,Protected,ReadProtected}]
SetAttributes[HPLArgTransform,{NHoldAll,Protected,ReadProtected}]
SetAttributes[HPLArgTransform,{NHoldAll,Protected,ReadProtected}]


End[]
Protect[Integrate]
Print["$HPLFunctions gives a list of the functions of the package.\n$HPLOptions gives a list of the options of the package."]
Print["More info in hep-ph/0507152, hep-ph/0703052 and at \n http://krone.physik.unizh.ch/~maitreda/HPL/"]
EndPackage[]



